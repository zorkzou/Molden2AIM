c-----------------------------------------------------------------------
c--- Molden2AIM: a utility to convert the format from MOLDEN to AIM-WFN.
c--- Written in FORTRAN 77 and a bit of FORTRAN 90, and tested on
c--- Windows, Linux, and MacOSX.
c---
c--- History of update:
c--- Ver.1.0.0, 11/23/2009, The first public version. Supports MOLPRO.
c--- Ver.1.1.0, 11/25/2009, Renormalization of b.s. (subroutine renorm).
c--- Ver.1.2.0, 12/02/2009, Supports spherical Basis functions.
c--- Ver.1.3.0, 12/10/2009, Supports ORCA ([Program] Orca).
c--- Ver.1.4.0, 06/08/2010, Supports CFOUR ([Program] Cfour; spdf only).
c--- Ver.1.5.0, 06/09/2010, Supports TURBOMOLE ([Program] Turbomole).
c--- Ver.2.0.0, 12/20/2010, Checks the AIM-WFN file.
c--- Ver.2.1.0, 12/01/2013, Supports Dalton2013/TeraChem; PP is allowed;
c---                        generate a standard Molden file.
c--- Ver.2.1.1, 12/03/2013, Supports ACES-II 2.9; bug fix.
c--- Ver.2.2.0, 12/23/2013, Supports MOLCAS with Cartesian functions and
c---                        CFour with g-functions.
c--- Ver.3.0.0, 05/20/2014, Generates NBO's *.47 file; Reads .ini file;
c---                        util/ReOrdAtm.f90 for Molpro's MOLDEN
c--- Ver.3.0.1, 07/04/2014, bug fix for NBO6.
c--- Ver.3.0.2, 07/22/2014, Supports NWChem.
c--- Ver.3.0.3, 09/10/2014, Supports BDF and PSI4 (sph. functions only).
c--- Ver.3.0.4, 10/22/2014, Supports CADPAC.
c--- Ver.3.0.5, 11/21/2014, Supports MRCC (Cart. & spherical functions).
c--- Ver.3.0.6, 02/19/2015, ReOrdAtm.f90 has been updated for CFour.
c--- Ver.3.1.0, 02/25/2015, Check NBO's .47 file.
c--- Ver.3.2.0, 12/18/2015, Supports NBO 6 (> May.2014), MOLDEN file
c---                        saved by Molden program (output from GAMESS/
c---                        Firefly/GAMESS-UK/Gaussian; but Q-Chem is
c---                        not supported), and Gabedit file.
c--- Ver.3.3.0, 01/24/2016, Generalized Wiberg bond order.
c--- Ver.3.3.1, 05/19/2016, Bug fix for MOLPRO's MOLDEN file with ECP.
c--- Ver.4.0.0, 06/02/2016, Generates WFX file;
c---                        Operation of MOLDEN file with cores has been
c---                        improved.
c--- Ver.4.0.1, 06/11/2016, Supports [PSEUDO] data block of MOLDEN;
c---                        WFX: computs spin multiplicity if the
c---                        numbers of alpha and beta electrons are
c---                        known.
c--- Ver.4.0.2, 12/05/2016, Bug fix for "Ene =" in TeraChem's MOLDEN
c--- Ver.4.1.0, 03/18/2017, WFX: EDF library; Read Multiplicity
c---                        MOLDEN file: Supports PySCF
c--- Ver.4.1.1, 04/21/2017, WFX: EDF library is updated.
c--- Ver.4.1.2, 04/29/2017, WFX: EDF library is updated.
c---
c--- E-mail: qcband@gmail.com
c-----------------------------------------------------------------------

      program Molden2AIM
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

c---  MOLDEN files generated by the following programs require special
c     modifications
      parameter(nprog=9)
      character*20 pname(nprog)
c                    1       2           3        4       5        6
      data pname/'ORCA','CFOUR','TURBOMOLE','JAGUAR','ACES2','MOLCAS',
c          7      8      9
     & 'PSI4','MRCC','NBO6'/

c---  Cartesian NC-/C-GTO; Spherical NC-/C-GTO
      dimension ncar(2),nsph(2)

      dimension ICntrl(8)
      logical doit,ifopen,ifwbo

      character*57 fwfn,fwfx,fnbo
      character*64 fmdn
      character*10 dt
      character*5 ver
      character*1 yn,L2U
      character*100 stline

c///////////////////////////////////////////////////////////////////////
c     head
c///////////////////////////////////////////////////////////////////////
      ver="4.1.2"
      dt="04/29/2017"
      call headprt(ver,dt)

c///////////////////////////////////////////////////////////////////////
c     Initialization
c///////////////////////////////////////////////////////////////////////
      ICntrl(1)=1         ! Generating a standard Molden file in Cartesian functions
      ICntrl(2)=1         ! Generating a WFN file
      ICntrl(3)=0         ! Generating a WFX file
      ICntrl(4)=0         ! Generating a NBO .47 file
      ICntrl(5)=0         ! Checking normalization for WFN
      ICntrl(6)=0         ! Checking normalization for WFX
      ICntrl(7)=0         ! Checking normalization for NBO's .47
      ICntrl(8)=0         ! Calculate Generalized Wiberg bond order when ICntrl(4) >= 0
                          !
                          ! >0:  always performs the operation without asking the user
                          ! =0:  asks the user whether to perform the operation
                          ! <0:  always neglect the operation without asking the user

      IAllMO=0            ! WFN and WFX
                          ! =0: print only the orbitals with occ. number > 5.0d-8
                          ! <0: print only the orbitals with occ. number > 0.1 (debug)
                          ! >0: print all the orbitals

      ICln=1              ! delete temporary files (1) or not (0)

      iprog=0             ! 1: ORCA, 2: CFOUR, 3: TURBOMOLE, 4: JAGUAR, ...
                          ! 0: other programs, or read [Program] xxx from MOLDEN.
                          ! If one of the above program is always used, you can provide
                          ! iprog here without defining [Program] xxx in MOLDEN any more.

      nosupp=0            ! Print supporting information (0) or not (.ne.0)

      irdecp=0            ! For ECP: read core information from Molden file
                          ! <=0: if the total_occupation_number is smaller than the
                          !      total_Za, ask the user whether to read core information
                          !  >0: always search and read core information

c///////////////////////////////////////////////////////////////////////
c     Port numbers
c///////////////////////////////////////////////////////////////////////
c     Do not modify the following port numbers.
c
c     Port numbers 4x: important input and output files
c     Port numbers 6x: temporary files used in sub. backupgto
c     Port numbers 7x: temporary files
c
      iini=40             ! m2a.ini
      imod=44             ! original molden file
      inmd=45             ! new molden file in Cartesian functions
      iwfn=46             ! wfn file
      iwfx=47             ! wfx file
      inbo=48             ! NBO 47 file
      iwbo=49             ! Generalized Wiberg bond order

      itmp=65             ! see backupgto
      igin=66             ! see backupgto
      igol=67             ! see backupgto
      iatm=70             ! coordinates
      igto=71             ! basis functions
      imol=72             ! MO data of Cartesian functions
      ispn=73             ! MO spin, occupation, and energy
      imo0=74             ! raw MO data; the missing zeros will be filled in
      icor=75             ! CORE data
      iedf=76             ! EDF data for ECP


c     The following integers will be determined later. Do not modify them here.
c
      ifc4=1              ! a scaling factor for occ. numbers: x 1 (1) or x 2 (2)
      iecp=0              ! PP (ECP or MCP) is used (> 0; = #core_electron) or not (0)
      lsph=0              ! MOs are in Cartesian (0) or spherical (1) basis functions

c     read user's parameters from m2a.ini
      call uinit(iini,nprog,ICntrl,ICln,IAllMO,iprog,nosupp,irdecp,
     & iunknw,stline)

c///////////////////////////////////////////////////////////////////////
c     program list which can save MOLDEN file
c///////////////////////////////////////////////////////////////////////
      if(nosupp .eq. 0) call SuppInf

c///////////////////////////////////////////////////////////////////////
c     define file names
c///////////////////////////////////////////////////////////////////////
      call filename(imod,fmdn,fwfn,fwfx,fnbo)

      open(iatm,file='atm123456789.tmp')
      open(igto,file='gto123456789.tmp')
      open(imol,file='mol123456789.tmp')
      open(ispn,file='spn123456789.tmp')
      open(imo0,file='mo0123456789.tmp')
      open(icor,file='cor123456789.tmp')
      open(iedf,file='edf123456789.tmp')

c///////////////////////////////////////////////////////////////////////
c     search [Program] and get the name of the program.
c     [Program] is a special keyword for Molden2AIM.
c     iprog = 0 (default), 1 (orca), 2 (cfour), 3 (turbomole), ...
c///////////////////////////////////////////////////////////////////////
      call getprog(imod,nprog,pname,iprog,stline)

c///////////////////////////////////////////////////////////////////////
c     backup molden file and delete some redundant (e.g. Pople GTO by
c     ACES2) or not useful data (e.g. unoccupied orb.s)
c///////////////////////////////////////////////////////////////////////
      call backupatm(imod,iatm,ifind,stline)
      if(ifind.eq.0)goto 9910           ! STOP: [ATOMS] was not found
      call natom(iatm,nat,nchar,iunit,ierr)  ! iunit = 0: Ang. 1: Bohr 2: Error
      if(ierr.ne.0)goto 9910            ! STOP: deMon2k's geometry optimization, or wrong ordering
      call backupgto(imod,igto,itmp,igin,igol,nat,iprog,ifind,stline)
      if(ifind.eq.0)goto 9910           ! STOP: [GTO] was not found, or wrong ordering
      call npgau(igto,Ierr,ncar,nsph,MaxL,stline)   ! # of uc. and c. GTO
      if(Ierr.eq.1)then
c---  For CFour, there may be basis functions higher than g
        write(*,*)"Error! Only S,P,D,F,G functions are supported!"
        write(*,*)"Please check your MOLDEN file."
        goto 9910
      else if(Ierr.eq.2)then
c---  ncar(1) > maxpg or ncar(2) > maxpgc
        goto 9910
      end if
c---  check: Car. vs Sph.
c      call checkcar(ncarmo,ifind,stline)
      call checkcar2(ncarmo,ishrt,ifind,stline)
      if(ifind.eq.0)goto 9910           ! STOP: [MO] was not found
      if(iprog .eq. 4)then
        ncarmo=ncar(2)
        ishrt=1
        lsph=0
        write(*,"(
     *    ' >>> Cartesian basis functions are used by Jaguar.',/)")
      else
        if(ncarmo.eq.ncar(2))then
          write(*,"(' >>> Cartesian basis functions are used.',/)")
          lsph=0
        else if(ncarmo.lt.ncar(2) .and. ncarmo.eq.nsph(2))then
          write(*,"(' >>> Spherical basis functions are used.',/)")
          lsph=1
c         molcas with spherical functions: do nothing
          if(iprog .eq. 6) iprog=-6
c         mrcc with spherical functions: do nothing
          if(iprog .eq. 8) iprog=-8
        else if(ncarmo.lt.ncar(2) .and. ncarmo.gt.nsph(2))then
          write(*,"(
     *    ' Wrong! NCARMO=',i5,', NCGTO=',i5,/,
     *    ' Sperical and Cartesian functions are mixed together.',/,
     *    ' This is not supported.')")
     *    ncarmo,ncar(2)
          goto 9910
        else
          write(*,"(' Wrong! NCARMO=',i5,', NCGTO=',i5,/)")
     *    ncarmo,ncar(2)
          goto 9910
        end if
      end if
c---  compute scaling factors of MO
      call moscale(igto,iprog,ncar(2))

c---  backup MO
      call fill0s(imo0,ncarmo,ishrt,stline)
      if(IAllMO .eq. 0)then
        tolocc=5.0d-8
      else if(IAllMO .gt. 0)then
        tolocc=-1.0d2
      else
        tolocc=1.0d-1 - 5.0d-8
      end if
      if(lsph.eq.0)then
        call backupmolc(imol,ispn,imo0,nmo,nmotot,sumocc,ifspin,ifbeta,
     &   ncar(2),tolocc,stline,ierr)
      else
        call backupmols(imol,ispn,imo0,nmo,nmotot,sumocc,ifspin,ifbeta,
     &   iprog,tolocc,stline,ierr)
      end if
      if(ierr.ne.0)then
        write(*,"(/,' Wrong! Star (*) is found in MO coefficients.',/,
     *' If the occupation is weak, please delete this MO and run again,'
     *,/,' otherwise you have to calculate the MO coefficient.')")
        goto 9910
      end if

      write(*,"(' >>> SUMMARY',//,
     & 5x,'Number of atoms: ',25x,i8,/,
     & 5x,'Maximum angular momentum: ',16x,i8,/,
     & 5x,'Number of primitive Cartesian functions: ',1x,i8,/,
     & 5x,'Number of contracted Cartesian functions: ',i8,/,
     & 5x,'Number of primitive spherical functions: ',1x,i8,/,
     & 5x,'Number of contracted spherical functions: ',i8,/,
     & 5x,'Number of orbitals to be printed: ',8x,i8)") nat,MaxL,
     & ncar(1),ncar(2),nsph(1),nsph(2),nmo

c///////////////////////////////////////////////////////////////////////
c     check
c///////////////////////////////////////////////////////////////////////
      if(iprog.ne.0)then
        call chkbstyp(lsph,iprog,MaxL,ierr)
        if(ierr.ne.0) goto 9910
      end if
      if(nmo.lt.1)then
        write(*,*)"Error! No occupied MOs are found!"
        write(*,*)
c       There is a bug in Dalton2013, which may have been solve now.
        if(iprog.eq.0) write(*,*)
     &    "If you are using Dalton, try the latest version."
c       In old version of MRCC, occ=0 if occupations are specified
        if(abs(iprog).eq.8) write(*,*)"Try the latest version of MRCC."
        goto 9910
      end if
      if(ncar(1).lt.1)then
        write(*,*)"Error! No Primitive Basis Functions are found!"
        write(*,*)
        write(*,*)"Please check your MOLDEN file."
        goto 9910
      end if
      if(nat.lt.1)then
        write(*,*)"Error! No atoms are found!"
        write(*,*)
        write(*,*)"Please check your MOLDEN file."
        goto 9910
      end if
      if(iunit.ne.1.and.iunit.ne.0)then
        write(*,*)"Error! The unit of the coordinates is not defined!"
        write(*,*)
        write(*,*)"Please check your MOLDEN file."
        goto 9910
      end if

      chanet = 0.d0

c     read core data?
      if(abs(dble(nchar)-sumocc) .gt. 0.001d0 .and. irdecp .le. 0)then
        write(*,"(//,' Is ECP or MCP used? ([Yes] / No)',/,' > ',$)")
        read(*,"(a1)")yn
        yn=L2U(yn)
        if(yn .ne. 'N') irdecp = 1
      end if
      if(irdecp .gt. 0)then
        call RdCore(iatm,imod,icor,nat,iecp,ierr,stline)
        if(ierr .ne. 0)goto 9910
      end if

      if(abs(dble(nchar-iecp)-sumocc) .gt. 0.001d0)then
        call chkcharge(nchar,sumocc,iprog,ifc4,iecp,chanet,ierr)
        if(ierr.ne.0)goto 9910
      end if
c     total number of electrons: core electrons by ECP should be excluded!
      ntote = nchar - iecp - nint(chanet)
coooc     this bug has been fixed by a modified version of libr/reorderdf.f
coooc      if(MaxL.ge.4 .and. iprog.eq.2)then
coooc        write(*,*)">>> Error!"
coooc        write(*,*)
coooc     *  "Molden2AIM cannot read G-functions for CFour!"
coooc        goto 9910
coooc      end if
      write(*,8000)

c///////////////////////////////////////////////////////////////////////
c     write a standard Molden file in Cartesian basis functions
c///////////////////////////////////////////////////////////////////////
      if(ICntrl(1) .gt. 0)then
        doit = .true.
      else if(ICntrl(1) .eq. 0)then
        write(*,"(////,
     *    ' Do you want to generate a new Molden file? ([Yes] / No)',/,
     *    ' > ',$)")
        read(*,"(a1)")yn
        yn=L2U(yn)
        if(yn.eq.'N')then
          doit = .false.
        else
          doit = .true.
        end if
      else
        doit = .false.
      end if

      if(doit) then
        call genmdn(fmdn,inmd,iatm,igto,imol,imo0,icor,ver,dt,nat,
     *    nmotot,ncarmo,ncar(2),ifc4,iecp,stline)
        write(*,8000)
      end if

c///////////////////////////////////////////////////////////////////////
c     write *.wfn
c///////////////////////////////////////////////////////////////////////
      if(ICntrl(2) .gt. 0)then
        doit = .true.
      else if(ICntrl(2) .eq. 0)then
        write(*,"(////,
     *    ' Do you want to generate a *.WFN file? ([Yes] / No)',/,
     *    ' > ',$)")
        read(*,"(a1)")yn
        yn=L2U(yn)
        if(yn.eq.'N')then
          doit = .false.
        else
          doit = .true.
        end if
      else
        doit = .false.
      end if

      if(doit) then
        call writitle(iwfn,fwfn,ver,dt)

        write(iwfn,"('GAUSSIAN',8x,i7,' MOL ORBITALS',i7,' PRIMITIVES',
     *    i9,' NUCLEI')")nmo, ncar(1), nat

        call writeatm(iwfn,iatm,icor,nat,iecp)
        call writecnt(iwfn,0,igto,imol,ncar(1))
        call writemol(iwfn,imol,nmotot,ncar(1),ncar(2),tolocc,ifc4,    ! ifc4=1 or 2 (CFour,Q-chem)
     *    stline)
        write(iwfn,"('END DATA')")
        write(iwfn,"(' THE  HF ENERGY =',f20.12,' THE VIRIAL(-V/T)=',
     *    f13.8)")0.d0,2.d0

c       Spin of MO. These data can be used by MultiWFN.
c       if ifspin=0, "Spin" cannot be found in Molden
        if(ifspin.eq.1) call writespn(iwfn,ispn,ifbeta,nmo)

c       final step
        call finalwfn(fwfn,iecp,MaxL)

c---    Check the AIM-WFN file
        if(ICntrl(5) .gt. 0)then
          doit = .true.
        else if(ICntrl(5) .eq. 0)then
          write(*,"(/,
     *    ' Do you want to check the *.WFN file? ([Yes] / No)')")
c         WFN with ECP is supported only by MultiWFN at present
          if(iecp .eq. 0) write(*,"(
     *    ' (Omit it if you are using AIMALL because AIMALL will',
     *    ' do it much faster.)')")
          write(*,"(' > ',$)")
          read(*,"(a1)")yn
          yn=L2U(yn)
          if(yn.eq.'N')then
            doit = .false.
          else
            doit = .true.
          end if
        else
          doit = .false.
        end if

        if(doit) then
          call CheckWFN(iwfn,nat,ncar(1),MaxL,info)
          if(info.ne.0) goto 9910
        end if
        write(*,8000)
      end if

c///////////////////////////////////////////////////////////////////////
c     write *.wfx
c///////////////////////////////////////////////////////////////////////
      if(ICntrl(3) .gt. 0)then
        doit = .true.
      else if(ICntrl(3) .eq. 0)then
        write(*,"(////,
     *    ' Do you want to generate a *.WFX file? ([Yes] / No)',/,
     *    ' > ',$)")
        read(*,"(a1)")yn
        yn=L2U(yn)
        if(yn.eq.'N')then
          doit = .false.
        else
          doit = .true.
        end if
      else
        doit = .false.
      end if

      if(doit) then

        call edfmain(icor,iedf,iecp,nat,nedf)

        call genwfx(iatm,igto,imol,ispn,icor,iedf,iwfx,fwfx,ver,dt,nat,
     &    nmotot,nmo,chanet,tolocc,ntote,ncar(1),ncar(2),nedf,iecp,
     &    ifc4,ifspin,ifbeta,iunknw,stline)

c       final step
        call finalwfx(fwfx,iecp,iunknw,MaxL)

c---    Check the AIM-WFX file
        if(ICntrl(6) .gt. 0)then
          doit = .true.
        else if(ICntrl(6) .eq. 0)then
          write(*,"(/,
     *    ' Do you want to check the *.WFX file? ([Yes] / No)',/,
     *    ' (Omit it if you are using AIMALL because AIMALL will',
     *    ' do it much faster.)',/,
     *    ' > ',$)")
          read(*,"(a1)")yn
          yn=L2U(yn)
          if(yn.eq.'N')then
            doit = .false.
          else
            doit = .true.
          end if
        else
          doit = .false.
        end if

        if(doit) then
          call CheckWFX(iwfx,nat,ncar(1),MaxL,info,stline)
          if(info.ne.0) goto 9910
        end if

        write(*,8000)
      end if

c///////////////////////////////////////////////////////////////////////
c     write NBO *.47
c///////////////////////////////////////////////////////////////////////
      if(ICntrl(4) .gt. 0)then
        doit = .true.
      else if(ICntrl(4) .eq. 0)then
        write(*,"(////,
     *    ' Do you want to generate NBO *.47 file? ([Yes] / No)',/,
     *    ' > ',$)")
        read(*,"(a1)")yn
        yn=L2U(yn)
        if(yn.eq.'N')then
          doit = .false.
        else
          doit = .true.
        end if
      else
        doit = .false.
      end if

      if(doit) then
        OPEN(inbo,FILE=fnbo)

c---    Generalized Wiberg bond order?
        if(ICntrl(8) .gt. 0)then
          doit = .true.
        else if(ICntrl(8) .eq. 0)then
          write(*,"(/,
     *    ' Do you want to calculate Wiberg bond order? ([Yes] / No)')")
          write(*,"(' > ',$)")
          read(*,"(a1)")yn
          yn=L2U(yn)
          if(yn.eq.'N')then
            doit = .false.
          else
            doit = .true.
          end if
        else
          doit = .false.
        end if
        ifwbo = doit
        if(doit) then
          lenth=Len_trim(fnbo)-3
          OPEN(iwbo,FILE=(fnbo(1:lenth)//'_wbo.out'))
        end if

        call cbsinf(igto,nat,nshell,nexp)
        call gennbo(inbo,iwbo,iatm,igto,imol,icor,ver,dt,nat,nshell,
     &   nexp,ncar(2),nmotot,MaxL,ifc4,iecp,ifwbo,info,stline)
        if(info.ne.0) goto 9910

c       final step
        call finalnbo(fnbo,MaxL)

c---    Check the NBO .47 file
        if(ICntrl(7) .gt. 0)then
          doit = .true.
        else if(ICntrl(7) .eq. 0)then
          write(*,"(/,
     *    ' Do you want to check the *.47 file? ([Yes] / No)')")
          write(*,"(' > ',$)")
          read(*,"(a1)")yn
          yn=L2U(yn)
          if(yn.eq.'N')then
            doit = .false.
          else
            doit = .true.
          end if
        else
          doit = .false.
        end if

        if(doit) then
          call CheckNBO(inbo,nat,ncar(2),sumocc*dble(ifc4),info,stline)
          if(info.ne.0) goto 9910
        end if
        write(*,8000)
      end if

c-----------------------------------------------------------------------
9910  continue
      inquire(unit=iini,opened=ifopen)
      if(ifopen) close(iini)
      close(imod)
      inquire(unit=inmd,opened=ifopen)
      if(ifopen) close(inmd)
      inquire(unit=iwfn,opened=ifopen)
      if(ifopen) close(iwfn)
      inquire(unit=iwfx,opened=ifopen)
      if(ifopen) close(iwfx)
      inquire(unit=inbo,opened=ifopen)
      if(ifopen) close(inbo)
      inquire(unit=iwbo,opened=ifopen)
      if(ifopen) close(iwbo)
      if(ICln .eq. 0)then
        close(iatm)
        close(igto)
        close(imol)
        close(ispn)
        close(imo0)
        close(icor)
        close(iedf)
      else
        close(iatm,status='delete')
        close(igto,status='delete')
        close(imol,status='delete')
        close(ispn,status='delete')
        close(imo0,status='delete')
        close(icor,status='delete')
        close(iedf,status='delete')
      end if

      call estop

8000  format(1x,77('='))
      end

c-----------------------------------------------------------------------
c-------EEEEEEEEEEEEE-----NNN-------NNN-----DDDDDDDDDDD-----------------
c-------EEEEEEEEEEEEE-----NNNN------NNN-----DDDDDDDDDDDD----------------
c-------EEE---------------NNNNN-----NNN-----DDD-------DDD---------------
c-------EEE---------------NNN-NN----NNN-----DDD-------DDD---------------
c-------EEEEEEEEEEEEE-----NNN--NN---NNN-----DDD-------DDD---------------
c-------EEEEEEEEEEEEE-----NNN---NN--NNN-----DDD-------DDD---------------
c-------EEE---------------NNN----NN-NNN-----DDD-------DDD---------------
c-------EEE---------------NNN-----NNNNN-----DDD-------DDD---------------
c-------EEEEEEEEEEEEE-----NNN------NNNN-----DDDDDDDDDDDD----------------
c-------EEEEEEEEEEEEE-----NNN-------NNN-----DDDDDDDDDDD-----------------
c-----------------------------------------------------------------------

c-----------------------------------------------------------------------
c---  Read user's initialization parameters from m2a.ini
c-----------------------------------------------------------------------
      Subroutine uinit(iini,nprog,ICntrl,ICln,IAllMO,iprog,nosupp,
     &  irdecp,iunknw,ctmp)
      Implicit Real*8(A-H,O-Z)
      Dimension ICntrl(8)
      character*100 ctmp
      parameter(nkey=14)
      character*9 keyword(nkey)
      data keyword/"MOLDEN=","WFN=","WFX=","NBO=","WFNCHECK=",
     & "WFXCHECK=","NBOCHECK=","WBO=",
     & "PROGRAM=","CLEAR=","IALLMO=","NOSUPP=","RDCORE=","UNKNOWN="/

      open(iini,file='m2a.ini',status='old',err=9000)
      rewind(iini)

      do while(.true.)
        read(iini,"(a100)",end=9000)ctmp

        if(ctmp(1:1) .eq. "$" .or. ctmp(1:1) .eq. "%" .or.
     &     ctmp(1:1) .eq. "!" .or. len_trim(ctmp) .eq. 0) cycle

        call charl2u(ctmp)
        ikey=0
        do i=1,nkey
          if(index(ctmp,trim(keyword(i))) .ne. 0) then
            ikey=i
            istart=index(ctmp,"=")+1
            read(ctmp(istart:100),*)keyvalue
            exit
          end if
        end do

        if(ikey .eq. 0) cycle

        select case(ikey)
          case(1:8)
            if(keyvalue .gt. 0) then
              keyvalue=1
            else if(keyvalue .lt. 0) then
              keyvalue=-1
            end if
            ICntrl(ikey)=keyvalue
          case(9)
            if(keyvalue .lt. 0 .or. keyvalue .gt. nprog) keyvalue=0
            iprog=keyvalue
          case(10)
            if(keyvalue .ne. 0) keyvalue=1
            ICln=keyvalue
          case(11)
            if(keyvalue .gt. 0)then
              keyvalue=1
            else if(keyvalue .lt. 0)then
              keyvalue=-1
            end if
            IAllMO=keyvalue
          case(12)
            nosupp = 0
            if(keyvalue .ne. 0) nosupp = 1
          case(13)
            irdecp = 0
            if(keyvalue .ne. 0) irdecp = 1
          case(14)
            iunknw = 0
            if(keyvalue .ne. 0) iunknw = 1
        end select
      end do
      close(iini)

9000  return
      End

c-----------------------------------------------------------------------
c---  generate NBO's *.47 data file (always in Cartesian functions).
c
c     Paremeters
c     inbo,iatm,igto
c                 : ports
c     ver,dt      : version number and date
c     natm        : # atoms
c     nshell      : # contracted shells
c     nexp        : # primitive exponents
c     nbas        : # contracted Cartesian basis functions
c     MaxL        : max L (<=4 at present)
c
c NOTE:
c
c 1) It requires overlap and density in contracted Cartesian functions.
c
c 2) Fock matrix is not available, so the 2'nd order of perturbation
c    cannot be calculated.
c
c 3) T and V: optional and not calculated here. They are not defined
c    in the case of all-electron scalar relativistic calculation.
c
c 4) $LCAOMO requires both occupied and unoccupied MOs, and #MO = #BAS.
c    However this may be not true since Cartesian basis functions are
c    always used here. Because of this reason, $LCAOMO is ignored at
c    present.
c
c 5) If ECP is used, you have to correct iz(2) in $COORD by hand.
c
c-----------------------------------------------------------------------
      subroutine gennbo(inbo,iwbo,iatm,igto,imol,icor,ver,dt,natm,
     & nshell,nexp,nbas,nmo,MaxL,ifc4,iecp,ifwbo,info,ctmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(au2ang=0.529177249d0)
c     scalmo will be used
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      logical ifwbo
c
      character*4 cnatm
      character*5 cnbas, ver
      character*10 dt
      character*100 ctmp
      dimension xyz(3,natm),ncomp(nshell),nprim(nshell),nptr(nshell),
     & ncshl(nshell),expn(nexp),con(nexp),nc(nbas),label(nbas)
      allocatable scr1(:),scr2(:),scr3(:)

      lsph=0    ! always in Cartesian functions
      ntt=nbas*(nbas+1)/2
      nss=max(225,nbas*nbas)    ! 225 is required in OvDriv2
      allocate(scr1(ntt),scr2(ntt),scr3(nss))

      ncore = 0
      rewind(icor)

      rewind(inbo)

      write(cnatm,"(i4)")natm
      cnatm=ADJUSTL(cnatm)
      write(cnbas,"(i5)")nbas
      cnbas=ADJUSTL(cnbas)

c     gennbo: $GENNBO
      write(inbo,"(' $GENNBO  NATOMS=',a4,' NBAS=',a5,
     *' UPPER  BODM  $END')")cnatm,cnbas

c     gennbo: $NBO
      write(inbo,"(' $NBO BNDIDX NLMO $END')")

c     gennbo: $COORD
      write(inbo,"(' $COORD')")
c---  if fdate doesn't work, just use this line
c      write(iwfn,"(' Molden2AIM, Version ',a5,' (',a10,')')")ver,dt
      call fdate(ctmp)
      call trulen(ctmp,L1,L2,length)
      write(inbo,"(' Molden2AIM, Version ',a5,' (',a10,')',11x,
     *'Time: ',a24)")ver,dt,ctmp(L1:L2)
c
      rewind(iatm)
      read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
      fc=1.d0
      if(iu .ne. 0)fc=au2ang
      do i=1,natm
        read(iatm,*)ctmp,ia,iz,xyz(1,i),xyz(2,i),xyz(3,i)
        call ascale(3,fc,xyz(1,i),xyz(1,i))
        if(iecp .gt. 0) read(icor,*) j, ncore
c       About NBO6:
c       1. It may lead to numerical errors of about 1.0d-6 in the overlap matrix,
c       which cannot pass the examination of NBO6. More digits should be printed.
c       2. au2ang: in NBO3, 0.529177249 is used instead of 0.529177. This may be
c       also true in NBO6.
cooo        write(inbo,"(1x,2i5,3f15.6)")iz,iz-ncore,(xyz(j,i),j=1,3)
        write(inbo,"(1x,2i5,3f18.9)")iz,iz-ncore,(xyz(j,i),j=1,3)
      end do
      write(inbo,"(' $END')")
c     xyz: Ang. --> Bohr
      call ascale(3*natm,(1.d0/au2ang),xyz,xyz)

c     read contracted basis functions from igto
      call RdConBF(igto,natm,nshell,nexp,nbas,lsph,ncomp,nprim,nptr,
     & ncshl,expn,con,nc,label)

c     gennbo: $BASIS
      call wrbas(inbo,nbas,nc,label)

c     gennbo: $CONTRACT
      call wrctr(inbo,nshell,nexp,MaxL,lsph,ncomp,nprim,nptr,expn,con,
     & scr1)

c     gennbo: $OVERLAP
      write(*,"(/,'  Calculating overlap matrix...')")
      call OvDriv2(inbo,nshell,nexp,nbas,MaxL,lsph,xyz,ncomp,nprim,
     & nptr,ncshl,expn,con,scr1,scr3,info)
        if(info.ne.0) return

c     gennbo: $DENSITY
      write(*,"('  Calculating density matrix...')")
      call DenDriv(inbo,imol,nbas,nmo,dble(ifc4),scalmo,scr2,scr3)

c     Generalized Wiberg bond order
c       1. natm .le. nbas is required, which should be true.
c       2. S (in scr1) and P (in scr2) will be destroyed.
      if(ifwbo) then
        write(*,"('  Calculating GWBO...')")
        call GWBO(iwbo,nbas,natm,nc,scr1,scr2,scr3,scr1)
      end if

      deallocate(scr1,scr2,scr3)

      return
      end

c-----------------------------------------------------------------------
c--- Generalized Wiberg bond order index, which is Mayer's bond order
c--- in the case of closed-shell.
c-----------------------------------------------------------------------
      subroutine GWBO(iwbo,N,Natm,icent,S,P,D,bo)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension icent(*),S(*),P(*),D(N,N),bo(Natm,Natm)
      parameter(NCol=10)
1010  format(' Generalized Wiberg bond order indices in MO.',//,
     &'   E(i,i) = Total WBO of atom i, and',/,
     &'   E(i,j) = WBO between atoms i and j.',/)
1020  format(/,' I_atm        ',10i8)
1030  format(i6,8x,10f8.4)

c     D = P * S
      call AClear(N*N,D)
      call LTxLT(N,P,S,D)

c     D = D .* D^T
      do i = 1, N
        do j = 1, i-1
          D(j,i) = D(i,j) * D(j,i)
c          D(i,j) = D(j,i)    ! not used
        end do
      end do

      call AClear(Natm*Natm,bo)
      do i = 1, N
        ii = icent(i)
        do j = 1, i-1
          jj = icent(j)
          if(ii .ne. jj)then
            bo(jj,ii) = bo(jj,ii) + D(j,i)
c            bo(ii,jj) = bo(jj,ii)    ! not used
            bo(ii,ii) = bo(ii,ii) + D(j,i)
            bo(jj,jj) = bo(jj,jj) + D(j,i)
          end if
        end do
      end do

      rewind(iwbo)
      write(iwbo,1010)

      NBlock=(Natm-1)/NCol+1
      do i=1,NBlock
        iv1=(i-1)*NCol+1
        iv2=min(i*NCol,Natm)
        write(iwbo,1020)(k,k=iv1,iv2)
        write(iwbo,*)
        do j=iv1,Natm
          write(iwbo,1030)j,(bo(k,j),k=iv1,min(iv2,j))
        end do
      end do

      return
      end

c-----------------------------------------------------------------------
c---  driver of density matrix calculation
c
c     nbas: # contracted Cartesian functions
c     nmo:  # MO
c     focc: a pre-factor of occupation number (1.0 or 2.0)
c     scalmo: scaling factors of MO coefficients
c-----------------------------------------------------------------------
      subroutine DenDriv(inbo,imol,nbas,nmo,focc,scalmo,Den,cmo)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(occtol=1.d-8)
      dimension scalmo(*),Den(*),cmo(*)

      NTTS=nbas*(nbas+1)/2
      call AClear(NTTS,Den)

      rewind(imol)
      do i=1,nmo
c       read occ. number & MO coefficients from imol (in Cartesian b.s.)
        read(imol,"(7x,f20.8)")occ
        read(imol,*)
        occ=focc*occ
        do ibs=1,nbas
          read(imol,*)idx,cmo(ibs)
          cmo(ibs)=cmo(ibs)*scalmo(ibs)
        end do
        if(abs(occ) .lt. occtol) cycle

c       density matrix
        j=0
        do ibs=1,nbas
          do jbs=1,ibs
            j=j+1
            Den(j)=Den(j)+occ*cmo(ibs)*cmo(jbs)
          end do
        end do

      end do

      call noiserm(Den,NTTS)
c      call PrtMtr(nbas,NTTS,1,Den)
      write(inbo,"(' $DENSITY')")
      write(inbo,"(2x,5e15.7e2)")(Den(i),i=1,NTTS)
      write(inbo,"(' $END')")

      return
      end

c-----------------------------------------------------------------------
c---  read core information from the [CORE] or [PSEUDO] block defined by
c     the user
c-----------------------------------------------------------------------
      subroutine RdCore(iatm,imod,icor,nat,ncor,ierr,ctmp)
      implicit real*8 (a-h,o-z)
      character*100 ctmp
      character*3 atom
      dimension ic(2,nat)
      logical ifind

      ierr = 1
      ncor = 0
      ifrm = 0    ! 0 [CORE] or 1 [PSEUDO]

      rewind(imod)
c     search [Core] / [PSEUDO]
      do while(.true.)
        read(imod,"(a100)",end=1100)ctmp
        if(LEN_TRIM(ctmp) .eq. 0 .or. index(ctmp,'[') .eq. 0) cycle
        call charl2u(ctmp)
        if(index(ctmp,'[CORE]') .gt. 0) exit
        if(index(ctmp,'[PSEUDO]') .gt. 0) then
          ifrm = 1
          exit
        end if
      end do

      ic=0
      rewind(iatm)
      read(iatm,*)
      do i=1,nat
        read(iatm,*)ctmp,IA,ic(1,i)
      end do

c     read core information
      if(ifrm .eq. 0) then
c       [CORE]
        do while(.true.)
          read(imod,"(a100)",end=1000)ctmp
          if(LEN_TRIM(ctmp) .eq. 0 .or. index(ctmp,'[') .ne. 0)goto 1000

          k=index(ctmp,":")
          if(k .le. 1) goto 9010

          read(ctmp(k+1:),*,err=9010,end=9010) icore
c         check: icore
          if(icore .lt. 0 .or. icore .gt. 120) goto 9035

          read(ctmp(1:k-1),*,err=9010,end=9010) atom
          call charl2u(atom)
          call trulen(atom,I,J,K)
          K=ichar(atom(I:I))
          if( (K .ge. 65) .and. (K .le. 90) ) then
            do L=I,J
              K=ichar(atom(L:L))
              if( (K .lt. 65) .or. (K .gt. 90) ) goto 9020
            end do
            call ElemZA(0,atom,za,za)
            IZ = nint(za)
c           check: ZA > icore
            if(IZ .le. icore) goto 9040
            ifind = .false.
c           search all atoms with ZA = IZ
            do L=1,nat
              if(ic(1,L) .eq. IZ) then
                ifind = .true.
                ic(2,L) = icore
              end if
            end do
            if(.not. ifind) goto 9050

          else if( (K .ge. 48) .and. (K .le. 57) ) then
            do L=I,J
              K=ichar(atom(L:L))
              if( (K .lt. 48) .or. (K .gt. 57) ) goto 9020
            end do
            read(atom,*)IA
            IZ = ic(1,IA)

c           check: IA <= NAtom
            if(IA .lt. 1 .or. IA .gt. nat) goto 9030
c           check: ZA(IA) > icore
            if(IZ .le. icore) goto 9040

            ic(2,IA) = icore

          else
            goto 9020
          end if

c         check ZA vs. icore: icore must be an even number (4f & 5f metals are excluded)
c          if(IZ .lt. 57 .or. IZ .gt. 103 .or.
c     &      (IZ .gt. 71 .and. IZ .lt. 89) ) then
          if(mod(icore,2) .ne. 0) goto 9060
c          end if
        end do

      else
c       [PSEUDO]
        do while(.true.)
          read(imod,"(a100)",end=1000)ctmp
          if(LEN_TRIM(ctmp) .eq. 0 .or. index(ctmp,'[') .ne. 0)goto 1000

          read(ctmp,*,err=9015,end=9015) atom,IA,icore

          IZ = ic(1,IA)
          icore = IZ - icore
c         check: icore
          if(icore .lt. 0 .or. icore .gt. 120) goto 9035

c         check: IA <= NAtom
          if(IA .lt. 1 .or. IA .gt. nat) goto 9030
c         check: ZA(IA) > icore
          if(IZ .le. icore) goto 9040

          ic(2,IA) = icore

c         check ZA vs. icore: icore must be an even number (4f & 5f metals are excluded)
c          if(IZ .lt. 57 .or. IZ .gt. 103 .or.
c     &      (IZ .gt. 71 .and. IZ .lt. 89) ) then
          if(mod(icore,2) .ne. 0) goto 9060
c          end if
        end do

      end if

1000  continue

c     write data to icor
      ncor = 0
      rewind(icor)
      do i=1,nat
        write(icor,"(2i5)")ic(1,i),ic(2,i)
        if(ic(2,i) .gt. 0) ncor = ncor + ic(2,i)
      end do

c     print core information
      if(ncor .gt. 0) then
        write(*,"(//,
     &  '  Core information',//,
     &  '    I    Atom       ZA    NCore',/)")
        do i=1,nat
          if(ic(2,i) .gt. 0) then
            call ElemZA(1,atom,ic(1,i),ctmp)
            write(*,"(i5,5x,a3,2i9)")i,atom,ic(1,i),ic(2,i)
          end if
        end do
        write(*,*)
      end if

1100  continue

      ierr = 0
      return

9010  write(*,"(//,' ### Error when reading core data! The format is',/,
     &  5x,'Iatom: Ncore  or  Element: Ncore')")
      write(*,"(2x,a)")trim(ctmp)
      return

9015  write(*,"(//,' ### Error when reading core data! The format is',/,
     &  5x,'Name  IAtom  ZA-Ncore')")
      write(*,"(2x,a)")trim(ctmp)
      return

9020  write(*,"(//,' ### Wrong! Unknown element or atom index in',
     &  ' the core data!',/)")
      write(*,"(2x,a)")trim(ctmp)
      return

9030  write(*,"(//,' ### Error in core data: IA is out of range!',/)")
      write(*,"(2x,a)")trim(ctmp)
      return

9035  write(*,"(//,
     &  ' ### Error in core data: Ncore is out of range!',/)")
      write(*,"(2x,a)")trim(ctmp)
      return

9040  write(*,"(//,' ### Error in core data: ZA <= NCore!',/)")
      write(*,"(2x,a)")trim(ctmp)
      return

9050  write(*,"(//,' ### Error in core data: No such an element in the',
     &' molecule!',/)")
      write(*,"(2x,a)")trim(ctmp)
      return

9060  write(*,"(//,
     &  ' ### Error in core data: odd Ncore has not been programmed!',/,
     &  ' Please contact the author.',/)")
      write(*,"(2x,a)")trim(ctmp)
      return

      end

c-----------------------------------------------------------------------
c---  driver of overlap matrix (contracted and spherical)
c-----------------------------------------------------------------------
      subroutine OvDriv2(inbo,nshell,nexp,nbas,MaxL,lsph,xyz,ncomp,
     &  nprim,nptr,ncshl,expn,con,SMat,scr,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension xyz(3,*),ncomp(nshell),nprim(nshell),nptr(nshell),
     & ncshl(nshell),expn(nexp),con(nexp)
      dimension ra(3),rb(3),ncat(0:4)
      dimension SMat(*),scr(15*15)
      dimension sblk(15*15)   ! for Cart. <lq|lq> integrals, lq <= g
      data ncat/0,1,4,10,20/

      pi=acos(-1.d0)
      NTTS=nbas*(nbas+1)/2
      call AClear(NTTS,SMat)

      IBS=0
      do ishell = 1, nshell
        ra(1) = xyz(1,ncshl(ishell))
        ra(2) = xyz(2,ncshl(ishell))
        ra(3) = xyz(3,ncshl(ishell))
        nspa=ncomp(ishell)     ! nspa & nspb: #Cart./sph. b.s. (depending on lsph) in a shell
        ityp = LQuant(nspa)    ! ityp & jtyp: 0 (s), 1 (p), 2 (d), ...
        npta=(ityp+1)*(ityp+2)/2
        i1 = nptr(ishell)
        i2 = i1 + nprim(ishell) - 1
        JBS=0
        do jshell = 1, ishell
          rb(1) = xyz(1,ncshl(jshell))
          rb(2) = xyz(2,ncshl(jshell))
          rb(3) = xyz(3,ncshl(jshell))
          nspb=ncomp(jshell)
          jtyp = LQuant(nspb)
          nptb=(jtyp+1)*(jtyp+2)/2
          rab = dist(ra,rb)
          j1 = nptr(jshell)
          j2 = j1 + nprim(jshell) - 1
c-------- for contracted shells ishell and jshell
          do igto = i1,i2
            as = expn(igto)
            acn= con(igto)
            do jgto = j1,j2
              bs = expn(jgto)
              bcn= con(jgto)
c------------ for primitive Cartesian GTO_i and GTO_j: sblk(nptb,npta)
              call poverlap(sblk,
     &          as,npta,ncat(ityp),ra, bs,nptb,ncat(jtyp),rb,
     &          pi,MaxL,rab,info)
                if(info.ne.0) goto 9000
c------------ for primitive spherical GTO_i and GTO_j: sblk(nspb,nspa)
              if(lsph .ne. 0 .and. (ityp .gt. 1 .or. jtyp .gt. 1))
     &          call car2sph(sblk,scr,npta,nptb,nspa,nspb)
c------------ do contraction for sblk(nspb,nspa)
              call AScale(nspa*nspb,acn*bcn,sblk,sblk)
              call PackLT(SMat,IBS,JBS,sblk,nspa,nspb,ishell.eq.jshell)
            end do
          end do
c
          JBS=JBS+nspb
        end do
        IBS=IBS+nspa
      end do

      call noiserm(SMat,NTTS)
c      call PrtMtr(nbas,NTTS,1,SMat)
      write(inbo,"(' $OVERLAP')")
      write(inbo,"(2x,5e15.7e2)")(SMat(i),i=1,NTTS)
      write(inbo,"(' $END')")

9000  return
      end

cc-----------------------------------------------------------------------
cc---  Print a group of lower triangular matrices
cc-----------------------------------------------------------------------
c      Subroutine PrtMtr(N,NT,M,A)
c      Implicit Real*8(A-H,O-Z)
c      Dimension A(NT,M)
c
c      Do I = 1,M
c        write(99,"(/,' ** Mat-',i3)")I
c        K2 = 0
c        Do J = 1,N
c          K1 = K2 + 1
c          K2 = K1 + J - 1
c          write(99,"(i4,1000d15.7)")J,(A(K,I),K=K1,K2)
c        end do
c      end do
c
c      Return
c      End
c
c-----------------------------------------------------------------------
c---  Removal of numerical noise before printing array A.
c     Some compilers print stars (***) if ABS(A(i)) <= 1.0d-100.
c-----------------------------------------------------------------------
      subroutine noiserm(A,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(eps=1.0d-20,zero=0.0d0)
      dimension A(*)

      do i=1,N
        if(abs(A(i)) .lt. eps) A(i)=zero
      end do

      return
      end

c-----------------------------------------------------------------------
c---  put overlap integrals of ci*cj*<IGTO|JGTO> into overlap matrix S.
c     IBS and JBS are row and column indices which have been finished
c     already.
c-----------------------------------------------------------------------
      subroutine PackLT(S,IBS,JBS,si,nspa,nspb,LT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension S(*),si(nspb,nspa)
      logical LT

      do i=1,nspa
        ii=IBS+i
        jj=JBS
        kk=IdxNTT(jj,ii)
        nspb2=nspb
        if(LT) nspb2=i
        do j=1,nspb2
          kk=kk+1
          S(kk)=S(kk)+si(j,i)
        end do
      end do

      return
      end

c-----------------------------------------------------------------------
c---  converts Cartesian matrix s to spherical matrix, and save to s:
c     amap^T * s(npta x nptb) * bmap --> s(nspa x nspb)
c-----------------------------------------------------------------------
      subroutine car2sph(s,tmp,npta,nptb,nspa,nspb)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension s(nptb,npta),tmp(*)
c     dmap, fmap, and gmap have been initialized in sph2car
      common/carsph/dmap(6,5),fmap(10,7),gmap(15,9)

C     First half of transformation:
      if(nptb .le. 3)then        ! S, P
        call acopy(nptb*npta,s,tmp)
      else if(nptb .eq. 6)then   ! Cart. D
        call MatMult(2,nspb,nptb,npta,dmap,s,tmp)
      else if(nptb .eq. 10)then  ! Cart. F
        call MatMult(2,nspb,nptb,npta,fmap,s,tmp)
      else if(nptb .eq. 15)then  ! Cart. G
        call MatMult(2,nspb,nptb,npta,gmap,s,tmp)
      end if

C     Second half of transformation:
      if(npta .le. 3)then        ! S, P
        call acopy(nspa*nspb,tmp,s)
      else if(npta .eq. 6)then   ! Cart. D
        call MatMult(1,nspb,npta,nspa,tmp,dmap,s)
      else if(npta .eq. 10)then  ! Cart. F
        call MatMult(1,nspb,npta,nspa,tmp,fmap,s)
      else if(npta .eq. 15)then  ! Cart. G
        call MatMult(1,nspb,npta,nspa,tmp,gmap,s)
      end if

      return
      end

c-----------------------------------------------------------------------
c     Mode = 1: C = A * B
c            2: C = A^T * B
c            3: C = A * B^T
c            4: C = A^T * B^T
c     where C(MxN), op(A)(MxL), and op(B)(LxN)
c-----------------------------------------------------------------------
      subroutine MatMult(Mode,M,L,N,A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(Zero=0.d0,One=1.d0)
      dimension A(*),B(*),C(*)

      LDC=M
      if(Mode .eq. 1)then
        LDA=M
        LDB=L
        call DGEMM('N','N',M,N,L,One,A,LDA,B,LDB,Zero,C,LDC)
      else if(Mode .eq. 2)then
        LDA=L
        LDB=L
        call DGEMM('T','N',M,N,L,One,A,LDA,B,LDB,Zero,C,LDC)
      else if(Mode .eq. 3)then
        LDA=M
        LDB=N
        call DGEMM('N','T',M,N,L,One,A,LDA,B,LDB,Zero,C,LDC)
      else if(Mode .eq. 4)then
        LDA=L
        LDB=N
        call DGEMM('T','T',M,N,L,One,A,LDA,B,LDB,Zero,C,LDC)
      end if

      return
      end

c-----------------------------------------------------------------------
c---  overlap integrals for primitive Cartesian GTO_i and GTO_j
c-----------------------------------------------------------------------
      subroutine poverlap(s6d, as,npta,ioffst,ra, bs,nptb,joffst,rb,
     &  pi,MaxL,rab,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension s6d(nptb,npta),ra(3),rb(3)

      do icat=1,npta
        ipat=icat+ioffst
c       normalization factor
        fna=fnorm_lmn(as,ipat)
        call pattml(ipat,l1,m1,n1,info)
          if(info.ne.0) goto 9000
        do jcat=1,nptb
          jpat=jcat+joffst
c         normalization factor
          fnb=fnorm_lmn(bs,jpat)
          call pattml(jpat,l2,m2,n2,info)
            if(info.ne.0) goto 9000
          call overlap2(s6d(jcat,icat),
     &     l1,m1,n1,as,ra,fna,  l2,m2,n2,bs,rb,fnb,
     &     pi,MaxL,rab)
        end do
      end do

9000  return
      end

c-----------------------------------------------------------------------
c---  calculate an overlap matrix element
c                  <as(ra);l1,m1,n1 | bs(rb);l2,m2,n2>
c     another version
c-----------------------------------------------------------------------
      subroutine overlap2(s,
     &  l1,m1,n1,as,ra,fna,  l2,m2,n2,bs,rb,fnb,
     &  pi,MaxL,rab)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension ra(3),rb(3),p(3),dgn(0:MaxL),pan(0:MaxL,3),pbn(0:MaxL,3)
      data one/1.d0/
      save one

c---  gamma = as + bs and (2*gamma)^-n
      g=as+bs
      dg=g+g
      dgn(0)=one
      do i=1,MaxL
        dgn(i)=dgn(i-1)/dg
      end do
      tmp1=sqrt(pi/g)

      s=fna*fnb*exp(-as*bs*rab*rab/g)*tmp1*tmp1*tmp1

c---  P point
      p(1)=(as*ra(1)+bs*rb(1))/g
      p(2)=(as*ra(2)+bs*rb(2))/g
      p(3)=(as*ra(3)+bs*rb(3))/g

c     pa^n and pb^n
      do j=1,3
        pan(0,j)=one
        pbn(0,j)=one
      end do
      if(MaxL .gt. 0)then
        do j=1,3
          pan(1,j)=p(j)-ra(j)
          pbn(1,j)=p(j)-rb(j)
        end do
        do i=2,MaxL
          do j=1,3
            pan(i,j)=pan(i-1,j)*pan(1,j)
            pbn(i,j)=pbn(i-1,j)*pbn(1,j)
          end do
        end do
      end if

      call integ(sx,MaxL,l1,l2,dgn,pan(0,1),pbn(0,1))
      call integ(sy,MaxL,m1,m2,dgn,pan(0,2),pbn(0,2))
      call integ(sz,MaxL,n1,n2,dgn,pan(0,3),pbn(0,3))
      s=s*sx*sy*sz

9000  return
      end

c-----------------------------------------------------------------------
c---  get LQ according to its number of components
c-----------------------------------------------------------------------
      function LQuant(ncomp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      select case(ncomp)
        case(1)
          LQuant=0
        case(3)
          LQuant=1
        case(5,6)
          LQuant=2
        case(7,10)
          LQuant=3
        case(9,15)
          LQuant=4
        case default
          write(*,"(' Error in LQuant!')")
          stop
      end select

      return
      end

c-----------------------------------------------------------------------
c--- write $CONTRACT
c-----------------------------------------------------------------------
      subroutine wrctr(inbo,nshell,nexp,MaxL,lsph,ncomp,nprim,nptr,expn,
     & con,tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*10 tag(10)
      data tag/
     *'   NCOMP =','   NPRIM =','    NPTR =','          ','     EXP =',
     *'      CS =','      CP =','      CD =','      CF =','      CG ='/
      dimension ncomp(nshell),nprim(nshell),nptr(nshell),expn(nexp),
     & con(nexp)
      dimension tmp(nexp)

      write(inbo,"(' $CONTRACT')")
      write(inbo,"('  NSHELL =',i7)")nshell
      write(inbo,"('    NEXP =',i7)")nexp

      nstep=10
      call lines(nshell,nstep,nline,last)
c     NCOMP
      call iwrite(tag(1),tag(4),inbo,nline,last,nstep,ncomp)
c     NPRIM
      call iwrite(tag(2),tag(4),inbo,nline,last,nstep,nprim)
c     NPTR
      call iwrite(tag(3),tag(4),inbo,nline,last,nstep,nptr)

      nstep=4
      call lines(nexp,nstep,nline,last)
c     EXP
      call fwrite(tag(5),tag(4),inbo,nline,last,nstep,expn)
c     CS
      nl = 1
      call cpcon('S',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
      call fwrite(tag(6),tag(4),inbo,nline,last,nstep,tmp)
c     CP
      if(MaxL .ge. 1)then
        nl = 3
        call cpcon('P',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
        call fwrite(tag(7),tag(4),inbo,nline,last,nstep,tmp)
      end if
c     CD
      if(MaxL .ge. 2)then
        nl = 5
        if(lsph .eq. 0) nl = 6
        call cpcon('D',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
        call fwrite(tag(8),tag(4),inbo,nline,last,nstep,tmp)
      end if
c     CF
      if(MaxL .ge. 3)then
        nl = 7
        if(lsph .eq. 0) nl = 10
        call cpcon('F',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
        call fwrite(tag(9),tag(4),inbo,nline,last,nstep,tmp)
      end if
c     CG
      if(MaxL .ge. 4)then
        nl = 9
        if(lsph .eq. 0) nl = 15
        call cpcon('G',nl,nshell,nexp,ncomp,nprim,expn,con,tmp)
        call fwrite(tag(10),tag(4),inbo,nline,last,nstep,tmp)
      end if

      write(inbo,"(' $END')")

      return
      end

c-----------------------------------------------------------------------
c---  copy contraction coefficients of a give LQ from con1 to con2
c     and then multiply the normalization factors
c     nl: # Cartesian or spherical functions of LQ
c-----------------------------------------------------------------------
      subroutine cpcon(al,nl,nshell,nexp,ncomp,nprim,ex,con1,con2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension ncomp(nshell),nprim(nshell),ex(nexp),con1(nexp),
     & con2(nexp)
      character*1 al

      call AClear(nexp,con2)
      ip=0
      do i=1,nshell
        if(ncomp(i) .eq. nl)then
          do j=1,nprim(i)
            ip = ip + 1
            con2(ip) = con1(ip) * fnorm(ex(ip),al)
          end do
        else
          ip = ip + nprim(i)
        end if
      end do

      return
      end

c-----------------------------------------------------------------------
c---  write $BASIS
c-----------------------------------------------------------------------
      subroutine wrbas(inbo,nbas,nc,label)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*10 tag(3)
      data tag/'  CENTER =','   LABEL =','          '/
      dimension nc(nbas),label(nbas)

      write(inbo,"(' $BASIS')")

      nstep=10
      call lines(nbas,nstep,nline,last)
c     CENTER
      call iwrite(tag(1),tag(3),inbo,nline,last,nstep,nc)
c     LABEL
      call iwrite(tag(2),tag(3),inbo,nline,last,nstep,label)

      write(inbo,"(' $END')")

      return
      end

c-----------------------------------------------------------------------
c---  write real array in the format a, n*f
c-----------------------------------------------------------------------
      subroutine fwrite(tag1,tag2,io,nline,last,nstep,fvec)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*10 tag1,tag2,ac
      dimension fvec(*)

      idx=0
      do i=1,nline
        if(i.eq.1)then
          ac=tag1
        else
          ac=tag2
        end if
        if(i.lt.nline)then
          write(io,1110)ac,(fvec(j),j=idx+1,idx+nstep)
          idx=idx+nstep
        else
          write(io,1110)ac,(fvec(j),j=idx+1,idx+last)
        end if
      end do

      return

1110  format(a10,4e16.7)
      end

c-----------------------------------------------------------------------
c---  write integer array in the format a, n*i
c-----------------------------------------------------------------------
      subroutine iwrite(tag1,tag2,io,nline,last,nstep,ivec)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*10 tag1,tag2,ac
      dimension ivec(*)

      idx=0
      do i=1,nline
        if(i.eq.1)then
          ac=tag1
        else
          ac=tag2
        end if
        if(i.lt.nline)then
          write(io,1110)ac,(ivec(j),j=idx+1,idx+nstep)
          idx=idx+nstep
        else
          write(io,1110)ac,(ivec(j),j=idx+1,idx+last)
        end if
      end do

      return

1110  format(a10,10i7)
      end

c-----------------------------------------------------------------------
c--- count the number of lines
c-----------------------------------------------------------------------
      subroutine lines(n1,n2,nline,last)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      nline=n1/n2
      last=n2
      if(mod(n1,n2).ne.0)then
        last=mod(n1,n2)
        nline=nline+1
      end if

      return
      end

c-----------------------------------------------------------------------
c---  read contracted basis functions
c     Note: the sp shells have been saved separately.
c-----------------------------------------------------------------------
      subroutine RdConBF(igto,natm,nshell,nexp,nbas,lsph,ncomp,nprim,
     & nptr,ncshl,expn,con,nc,label)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension ncomp(nshell),nprim(nshell),nptr(nshell),ncshl(nshell),
     & expn(nexp),con(nexp),nc(nbas),label(nbas)
      character*1 lq

      iatm = 1
      ishell = 0
      iexp = 0
      ibas = 0
      rewind(igto)
      read(igto,*)    ! skip " 1  0"
      do while(.true.)
        read(igto,*)lq,ncon
        if(lq .eq. 'E')then
          iatm = iatm + 1
          if(iatm .gt. natm)then
            exit
          else
            read(igto,*)    ! skip " n  0"
            cycle
          end if
        end if

        ishell = ishell + 1
c
        nprim(ishell) = ncon
c
        if(ishell .gt. 1)then
          nptr(ishell) = nptr(ishell-1)+nprim(ishell-1)
        else
          nptr(ishell) = 1
        end if
c
        ncshl(ishell) = iatm
c
c     Pattern in MOLDEN format:
c      5D: D 0, D+1, D-1, D+2, D-2
c          255  252  253  254  251
c      6D: xx, yy, zz, xy, xz, yz
c          201 204 206 202 203 205
c      7F: F 0, F+1, F-1, F+2, F-2, F+3, F-3
c          351  352  353  354  355  356  357
c     10F: xxx, yyy, zzz, xyy, xxy, xxz, xzz, yzz, yyz, xyz
c          301  307  310  304  302  303  306  309  308  305
c      9G: G 0, G+1, G-1, G+2, G-2, G+3, G-3, G+4, G-4
c          451  452  453  454  455  456  457  458  459
c     15G: xxxx yyyy zzzz xxxy xxxz yyyx yyyz zzzx zzzy xxyy xxzz yyzz xxyz yyxz zzxy
c          401  411  415  402  403  407  412  410  414  404  406  413  405  408  409
c
c     Labels used in NBO (see Section B.7.5 of the manual)
c
c     s     x     y     z                                               !  4 * cart s, p
c     001   101   102   103
c
c     s     px    py    pz                                              !  4 * pure s, p
c     001   101   102   103
c
c     xx    xy    xz    yy    yz    zz                                  !  6 * cart d
c     201   202   203   204   205   206
c
c     d2-   d1+   d1-   d2+   d0                                        !  5 * pure d
c     251   252   253   254   255
c
c     xxx   xxy   xxz   xyy   xyz   xzz   yyy   yyz   yzz   zzz         ! 10 * cart f
c     301   302   303   304   305   306   307   308   309   310
c
c     f0    f1+   f1-   f2+   f2-   f3+   f3-                           !  7 * pure f
c     351   352   353   354   355   356   357
c
c     xxxx  xxxy  xxxz  xxyy  xxyz  xxzz  xyyy  xyyz  xyzz  xzzz        ! 15 * cart g
c     yyyy  yyyz  yyzz  yzzz  zzzz
c     401   402   403   404   405   406   407   408   409   410
c     411   412   413   414   415
c
c     g0    g1+   g1-   g2+   g2-   g3+   g3-   g4+   g4-               !  9 * pure g
c     451   452   453   454   455   456   457   458   459
c
c     The real spherical harmonics are defined in
c     http://en.wikipedia.org/wiki/Table_of_spherical_harmonics
c
        if(lq .eq. 'S')then
          ncomp(ishell) = 1
          label(ibas + 1) = 001
        else if(lq .eq. 'P')then
          ncomp(ishell) = 3
          label(ibas + 1) = 101
          label(ibas + 2) = 102
          label(ibas + 3) = 103
        else if(lq .eq. 'D')then
          if(lsph .eq. 0) then
            ncomp(ishell) = 6
            label(ibas + 1) = 201
            label(ibas + 2) = 204
            label(ibas + 3) = 206
            label(ibas + 4) = 202
            label(ibas + 5) = 203
            label(ibas + 6) = 205
          else
            ncomp(ishell) = 5
            label(ibas + 1) = 255
            label(ibas + 2) = 252
            label(ibas + 3) = 253
            label(ibas + 4) = 254
            label(ibas + 5) = 251
          end if
        else if(lq .eq. 'F')then
          if(lsph .eq. 0) then
            ncomp(ishell) = 10
            label(ibas + 1) = 301
            label(ibas + 2) = 307
            label(ibas + 3) = 310
            label(ibas + 4) = 304
            label(ibas + 5) = 302
            label(ibas + 6) = 303
            label(ibas + 7) = 306
            label(ibas + 8) = 309
            label(ibas + 9) = 308
            label(ibas +10) = 305
          else
            ncomp(ishell) = 7
            label(ibas + 1) = 351
            label(ibas + 2) = 352
            label(ibas + 3) = 353
            label(ibas + 4) = 354
            label(ibas + 5) = 355
            label(ibas + 6) = 356
            label(ibas + 7) = 357
          end if
        else if(lq .eq. 'G')then
          if(lsph .eq. 0) then
            ncomp(ishell) = 15
            label(ibas + 1) = 401
            label(ibas + 2) = 411
            label(ibas + 3) = 415
            label(ibas + 4) = 402
            label(ibas + 5) = 403
            label(ibas + 6) = 407
            label(ibas + 7) = 412
            label(ibas + 8) = 410
            label(ibas + 9) = 414
            label(ibas +10) = 404
            label(ibas +11) = 406
            label(ibas +12) = 413
            label(ibas +13) = 405
            label(ibas +14) = 408
            label(ibas +15) = 409
          else
            ncomp(ishell) = 9
            label(ibas + 1) = 451
            label(ibas + 2) = 452
            label(ibas + 3) = 453
            label(ibas + 4) = 454
            label(ibas + 5) = 455
            label(ibas + 6) = 456
            label(ibas + 7) = 457
            label(ibas + 8) = 458
            label(ibas + 9) = 459
          end if
        end if
c
        do i=1,ncomp(ishell)
          ibas = ibas + 1
          nc(ibas) = iatm
        end do
c       basis functions in igto have been normalized
        do i=1,ncon
          iexp = iexp + 1
          read(igto,*)expn(iexp),con(iexp)
        end do
      end do

      return
      end

c-----------------------------------------------------------------------
c---  collects information of contracted basis functions
c     Note: the sp shells have been saved separately.
c-----------------------------------------------------------------------
      subroutine cbsinf(igto,natm,nshell,nexp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*1 lq

      iatm = 1
      nshell = 0
      nexp = 0
      rewind(igto)
      read(igto,*)    ! skip " 1  0"
      do while(.true.)
        read(igto,*)lq,ncon
        if(lq .eq. 'E')then
          iatm = iatm + 1
          if(iatm .gt. natm)then
            exit
          else
            read(igto,*)    ! skip " n  0"
            cycle
          end if
        end if

        nshell = nshell + 1
        nexp = nexp + ncon
        do i=1,ncon
          read(igto,*)
        end do
      end do

      return
      end

c-----------------------------------------------------------------------
c--- search [Program] and get the name of the program.
c--- [Program] is a special keyword for Molden2AIM.
c--- iname = 0 (default), 1 (orca), 2 (cfour), 3 (turbomole), ...
c--- < 0: same as 0 except the name of QC program is known.
c---
c--- If MOLCAS uses spherical functions, iname will be reset to -6 later.
c-----------------------------------------------------------------------
      subroutine getprog(imod,nprog,pname,iname,tmp1)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp1
      character*20 pname(nprog)
1010  format(' >>> This MOLDEN file was generated by ',a,/)

c     iname is known
      if(iname .ge. 1 .and. iname .le. nprog) then
        write(*,1010)trim(pname(iname))
        return
      end if

c     iname is unknown
      iname = 0
      rewind(imod)
100   read(imod,"(100a)",end=9999)tmp1
      call charl2u(tmp1)
      if(index(tmp1,'[PROGRAM]').ne.0) goto 200
      goto 100
c     FORMAT:
c     [PROGRAM] pname
c          or
c     [PROGRAM]
c       pname
200   i=len_trim(tmp1)+1
      if(i .lt. 100)then
        read(imod,"(100a)",end=9999)tmp1(i:)
        call charl2u(tmp1(i:))
      end if

      do i=1,nprog
        if(index(tmp1,trim(pname(i))) .ne. 0)then
          iname=i
          write(*,1010)trim(pname(iname))
          exit
        end if
      end do

9999  return
      end

c-----------------------------------------------------------------------
c---  Check the NBO's .47 file
c-----------------------------------------------------------------------
      subroutine CheckNBO(inbo,NAtom,NC,TotE1,info,ctmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(tole=5.d-5,tola=1.d-6)
      character*100 ctmp
      allocatable S(:),P(:)

      info=1
      NTT=NC*(NC+1)/2

c---  read S & P from the *.47 file
      rewind(inbo)
      allocate(S(NTT),P(NTT))
      do while(.true.)
        read(inbo,"(a100)",err=5000,end=5000)ctmp
        if(index(ctmp,"$OVERLAP") .ne. 0) then
          write(*,6010)
          read(inbo,*,err=5000,end=5000)(S(i),i=1,NTT)
        else if(index(ctmp,"$DENSITY") .ne. 0) then
          write(*,6020)
          read(inbo,*,err=5000,end=5000)(P(i),i=1,NTT)
          exit
        end if
      end do

      TotE2 = TracLL(NC,S,P)

      DifE=abs(TotE1-TotE2)
      DifA=DifE/dble(NAtom)
      write(*,6110)TotE1
      write(*,6120)TotE2
      write(*,6130)DifE,DifA
      if(NAtom .lt. 30) then
        if(DifE .gt. tole) write(*,6210)
      else
        if(DifA .gt. tola) write(*,6210)
      end if

      info=0

5000  deallocate(S,P)
      return

6010  format(/,"  Reading overlap matrix...")
6020  format("  Reading density matrix...")
6110  format(/,"  Sum of MO Occupancies",22x," = ",f18.10)
6120  format("  Analytically integrated number of electrons = ",f18.10)
6130  format("  Difference",33x," = ",f18.10,/,
     &"  Difference per atom",24x," = ",f18.10)
6210  format(/,' ### Warning! Normalization check failed.')
      end

c-----------------------------------------------------------------------
c---  Check the AIM-WFN file
c-----------------------------------------------------------------------
      subroutine CheckWFN(iwfn,MaxAtm,maxpg,MaxL,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(tole=5.d-5,tola=1.d-6)
      dimension r(3,MaxAtm),Expon(maxpg),CMO(maxpg),FNor(maxpg),
     & ICent(maxpg),IType(maxpg)
      allocatable smat(:)

      info=0

c---  read basis function from the *.WFN file
      write(*,6010)
      call RdBas(iwfn,MaxAtm,maxpg,NMO,NGauss,NAtom,r,Expon,ICent,IType,
     &  FNor,info)
        if(info.ne.0) goto 5010
c---  compute the overlap matrix
      write(*,6020)
      allocate(smat(maxpg*(1+maxpg)/2))
      call OvDriver(smat,NGauss,IType,Expon,r,ICent,MaxL,info)
        if(info.ne.0) goto 5000
c      call PrtMtr(NGauss, (NGauss*(NGauss+1)/2), 1, smat)

c---  compute the number of electrons
      write(*,6030)
      TotE1=0.d0
      TotE2=0.d0
      do i=1,NMO
        call RdMO(iwfn,NGauss,Occ,CMO,FNor)
        TotE1=TotE1+Occ
        TotE2=TotE2+Occ*VSV(NGauss,CMO,smat)
      end do

      DifE=abs(TotE1-TotE2)
      DifA=DifE/dble(NAtom)
      write(*,6110)TotE1
      write(*,6120)TotE2
      write(*,6130)DifE,DifA
      if(NAtom .lt. 30) then
        if(DifE .gt. tole) write(*,6210)
      else
        if(DifA .gt. tola) write(*,6210)
      end if

5000  deallocate(smat)
5010  return

6010  format(/,"  Reading basis functions...")
6020  format("  Computing the overlap matrix...")
6030  format("  Computing the integrated number of electrons...")
6110  format(/,"  Sum of MO Occupancies",22x," = ",f18.10)
6120  format("  Analytically integrated number of electrons = ",f18.10)
6130  format("  Difference",33x," = ",f18.10,/,
     &"  Difference per atom",24x," = ",f18.10)
6210  format(/,' ### Warning! Normalization check failed.')
      end

c-----------------------------------------------------------------------
c---  Check the AIM-WFX file
c-----------------------------------------------------------------------
      subroutine CheckWFX(iwfx,MaxAtm,maxpg,MaxL,info,ctmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(tole=5.d-5,tola=1.d-6)
      dimension r(3,MaxAtm),Expon(maxpg),CMO(maxpg),FNor(maxpg),
     & ICent(maxpg),IType(maxpg)
      allocatable smat(:),Occ(:)
      character*100 ctmp
      character*42 tag

      info=0

c---  read basis function from the *.WFX file
      write(*,6010)
      call RdBsx(iwfx,MaxAtm,maxpg,NMO,NGauss,NAtom,r,Expon,ICent,IType,
     &  FNor,ctmp,tag,info)
        if(info.ne.0) goto 5010

c---  compute the overlap matrix
      write(*,6020)
      allocate(smat(maxpg*(1+maxpg)/2))
      allocate(Occ(NMO))
      call OvDriver(smat,NGauss,IType,Expon,r,ICent,MaxL,info)
        if(info.ne.0) goto 5000

c     Occ
      rewind(iwfx)
      tag = "<Molecular Orbital Occupation Numbers>"
      do while(.true.)
        read(iwfx,"(a100)",end=5020)ctmp
        if(index(ctmp,tag(1:38)) .ne. 0) exit
      end do
      read(iwfx,*,err=5020,end=5020) (Occ(i),i=1,NMO)

c     MO block
      rewind(iwfx)
      tag = "<Molecular Orbital Primitive Coefficients>"
      do while(.true.)
        read(iwfx,"(a100)",end=5020)ctmp
        if(index(ctmp,tag(1:42)) .ne. 0) exit
      end do

c---  compute the number of electrons
      write(*,6030)
      TotE1=0.d0
      TotE2=0.d0
      do i=1,NMO
        call RdMOx(iwfx,NGauss,CMO,FNor,ctmp,tag,info)
        if(info.ne.0) goto 5000
        TotE1=TotE1+Occ(i)
        TotE2=TotE2+Occ(i)*VSV(NGauss,CMO,smat)
      end do

      DifE=abs(TotE1-TotE2)
      DifA=DifE/dble(NAtom)
      write(*,6110)TotE1
      write(*,6120)TotE2
      write(*,6130)DifE,DifA

      if(NAtom .lt. 30) then
        if(DifE .gt. tole) write(*,6210)
      else
        if(DifA .gt. tola) write(*,6210)
      end if

5000  deallocate(smat)
      deallocate(Occ)
5010  return

5020  write(*,"(/,' ### Error when reading MO in the WFX file!')")
      info=1
      goto 5000

6010  format(/,"  Reading basis functions...")
6020  format("  Computing the overlap matrix...")
6030  format("  Computing the integrated number of electrons...")
6110  format(/,"  Sum of MO Occupancies",22x," = ",f18.10)
6120  format("  Analytically integrated number of electrons = ",f18.10)
6130  format("  Difference",33x," = ",f18.10,/,
     &"  Difference per atom",24x," = ",f18.10)
6210  format(/,' ### Warning! Normalization check failed.')
      end

c-----------------------------------------------------------------------
c--- read MO coefficients from the *.WFX file
c-----------------------------------------------------------------------
      subroutine RdMOx(iwfx,NGauss,CMO,FNor,ctmp,tag,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension CMO(*),FNor(*)
      character*100 ctmp
      character*12 tag

      tag = "</MO Number>"
      info= 0
      do while(.true.)
        read(iwfx,"(a100)",end=9010)ctmp
        if(index(ctmp,tag(1:12)) .ne. 0) exit
      end do
      read(iwfx,*,err=9010,end=9010)(CMO(i),i=1,NGauss)

      do i=1,NGauss
        CMO(i)=CMO(i)/FNor(i)
      end do
      return

9010  write(*,"(/,' ### Error when reading MO in the WFX file!')")
      info=1
      return
      end

c-----------------------------------------------------------------------
c--- read basis function from the *.WFX file
c-----------------------------------------------------------------------
      subroutine RdBsx(iwfx,MaxAtm,MaxPG,NMO,NGauss,NAtom,r,Expon,ICent,
     &  IType,FNor,ctmp,tag,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension r(3,*),Expon(*),ICent(*),IType(*),FNor(*)
      character*100 ctmp
      character*42 tag

      info=0

c     NMO
      rewind(iwfx)
      tag = "<Number of Occupied Molecular Orbitals>"
      do while(.true.)
        read(iwfx,"(a100)",end=9010)ctmp
        if(index(ctmp,tag(1:39)) .ne. 0) exit
      end do
      read(iwfx,*,err=9010,end=9010) NMO

c     NAtom
      rewind(iwfx)
      tag = "<Number of Nuclei>"
      do while(.true.)
        read(iwfx,"(a100)",end=9010)ctmp
        if(index(ctmp,tag(1:18)) .ne. 0) exit
      end do
      read(iwfx,*,err=9010,end=9010) NAtom

c     NGauss
      rewind(iwfx)
      tag = "<Number of Primitives>"
      do while(.true.)
        read(iwfx,"(a100)",end=9010)ctmp
        if(index(ctmp,tag(1:22)) .ne. 0) exit
      end do
      read(iwfx,*,err=9010,end=9010) NGauss

c     check
      if(NAtom .ne. MaxAtm) goto 9920
      if(NGauss .ne. MaxPG) goto 9930

c     coordinates
      rewind(iwfx)
      tag = "<Nuclear Cartesian Coordinates>"
      do while(.true.)
        read(iwfx,"(a100)",end=9010)ctmp
        if(index(ctmp,tag(1:31)) .ne. 0) exit
      end do
      read(iwfx,*,err=9010,end=9010) ((r(i,j), i=1,3), j=1,NAtom)

c     GTO Center
      rewind(iwfx)
      tag = "<Primitive Centers>"
      do while(.true.)
        read(iwfx,"(a100)",end=9010)ctmp
        if(index(ctmp,tag(1:19)) .ne. 0) exit
      end do
      read(iwfx,*,err=9010,end=9010) (ICent(i),i=1,NGauss)

c     GTO Type
      rewind(iwfx)
      tag = "<Primitive Types>"
      do while(.true.)
        read(iwfx,"(a100)",end=9010)ctmp
        if(index(ctmp,tag(1:17)) .ne. 0) exit
      end do
      read(iwfx,*,err=9010,end=9010) (IType(i),i=1,NGauss)

c     GTO Exponent
      rewind(iwfx)
      tag = "<Primitive Exponents>"
      do while(.true.)
        read(iwfx,"(a100)",end=9010)ctmp
        if(index(ctmp,tag(1:21)) .ne. 0) exit
      end do
      read(iwfx,*,err=9010,end=9010) (Expon(i),i=1,NGauss)

c---  compute normalization factors
      do i=1,NGauss
        FNor(i)=fnorm_lmn(Expon(i),IType(i))
      end do

1000  return

9010  write(*,"(/,' ### Error when reading the WFX file!')")
      info=1
      return
9920  write(*,"(/,' ### Wrong! NAtom .ne. MaxAtm:',2i8)")NAtom,MaxAtm
      info=1
      return
9930  write(*,"(/,' ### Wrong! NGauss .ne. MaxPG:',2i8)")NGauss,MaxPG
      info=1
      return
      end

c-----------------------------------------------------------------------
c---  v * S * v', S is a symmetric L.T. matrix
c-----------------------------------------------------------------------
      function VSV(N,v,s)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension v(N),s(*)

      p=0.d0
      do i=1,N
        k=IdxNTT(1,i)-1
        do j=1,i-1
          k=k+1
          q=v(j)*s(k)*v(i)
          p=p+q+q
        end do
        k=k+1
        q=v(i)*s(k)*v(i)
        p=p+q
      end do
      VSV=p

      return
      end

c-----------------------------------------------------------------------
c---  Trace of the product of lower triangular matrices A and B.
c-----------------------------------------------------------------------
      Function TracLL(N,A,B)
      Implicit Real*8(A-H,O-Z)
      Dimension A(*), B(*)

      Su = 0.0d0
      Do I = 1, N
        II = (I*(I-1))/2
        Do J = 1, I-1
          Su = Su + (A(II+J)+A(II+J))*B(II+J)
        End Do
        Su = Su + A(II+I)*B(II+I)
      End Do

      TracLL = Su
      Return
      End

c-----------------------------------------------------------------------
c---  It returns the position of element (J,I) in a L.T. matrix.
c     J must be .LE. I. It doesn't work if J > I.
c-----------------------------------------------------------------------
      Function IdxNTT(J,I)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      IdxNTT=J+(I-1)*I/2

      Return
      End

c-----------------------------------------------------------------------
c--- read MO coefficients from the *.WFN file
c-----------------------------------------------------------------------
      subroutine RdMO(iwfn,NGauss,Occ,CMO,FNor)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension CMO(*),FNor(*)

      read(iwfn,"(34x,f13.7)")Occ
      read(iwfn,"(5d16.8)")(CMO(i),i=1,NGauss)
      do i=1,NGauss
        CMO(i)=CMO(i)/FNor(i)
      end do

      return
      end

c-----------------------------------------------------------------------
c--- driver of overlap matrix
c-----------------------------------------------------------------------
      subroutine OvDriver(s,NGauss,IType,Expon,r,ICent,MaxL,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension s(*),r(3,*),Expon(*),ICent(*),IType(*)

      k=0
      do i=1,NGauss
        do j=1,i
          k=k+1
          call overlap(s(k),IType(i),Expon(i),r(1,ICent(i)),
     *                      IType(j),Expon(j),r(1,ICent(j)),MaxL,info)
          if(info.ne.0) goto 100
        end do
      end do

100   return
      end

c-----------------------------------------------------------------------
c--- read basis function from the *.WFN file
c-----------------------------------------------------------------------
      subroutine RdBas(iwfn,MaxAtm,MaxPG,NMO,NGauss,NAtom,r,Expon,ICent,
     &  IType,FNor,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension r(3,*),Expon(*),ICent(*),IType(*),FNor(*)

      info=0
      rewind(iwfn)
      read(iwfn,"(/,16x,i7,13x,i7,11x,i9)")NMO,NGauss,NAtom
      if(NAtom .ne. MaxAtm)then
        write(*,"(/,' ### Wrong! NAtom .ne. MaxAtm:',2i8)")NAtom,MaxAtm
        info=1
        goto 1000
      end if
      if(NGauss .ne. MaxPG)then
        write(*,"(/,' ### Wrong! NGauss .ne. MaxPG:',2i8)")NGauss,MaxPG
        info=1
        goto 1000
      end if

      do i=1,NAtom
        read(iwfn,"(24x,3f12.8)")r(1,i),r(2,i),r(3,i)
      end do

      read(iwfn,"(20x,20i3)")(ICent(i),i=1,NGauss)
      read(iwfn,"(20x,20i3)")(IType(i),i=1,NGauss)
      read(iwfn,"(10x,5d14.7)")(Expon(i),i=1,NGauss)

c---  compute normalization factors
      do i=1,NGauss
        FNor(i)=fnorm_lmn(Expon(i),IType(i))
      end do

1000  return
      end

c-----------------------------------------------------------------------
c--- check charge
c-----------------------------------------------------------------------
      subroutine chkcharge(nchar,sumocc,iprog,ifc4,iecp,chanet,ierr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*1 ioc

      ierr=1
      chanet=dble(nchar-iecp)-sumocc
      write(*,"(//,' Warning: the total electron is different from the',
     &  ' sum of occupations!',//,4x,
     &  '#Electron        =',f10.4,/,4x,'Sum_Occupation   =',f10.4,/,4x,
     &  '#Core Electron   =',f10.4,/,4x,'Net Charge       =',f10.4,//,
     &  ' The reasons may be',/,
     &  ' 1) semi-empirical Hamiltonian is used,')")
     &  dble(nchar),sumocc,dble(iecp),chanet
      if(chanet .ge. 0) then
        write(*,"(' 2) ionic system with net charge',f8.2,',')")chanet
      else
        write(*,"(' 2) anionic system with net charge',f8.2,',')")chanet
      end if
c     C4: RHF; Q-Chem: RHF, RDFT, ROGF, RODFT
      write(*,"(' 3) beta MOs of R-/RO-SCF are not printed by CFOUR or'
     &  ' Q-Chem, and therefore',/,
     &  '    the occupation numbers should be multiplied by 2.0,',/,
     &  ' 4) other reasons.',//,
     &  ' Which one corresponds to your case?',/,' > ',$)")

      read(*,*)ioc

      select case(ioc)
        case("1")
          write(*,"(/,
     *    ' semi-empirical Hamiltonian is not supported.')")
          goto 9910
        case("2")
          docc=abs(ANINT(sumocc)-sumocc)
          if(docc .lt. 1.d-4)then
            if(chanet .ge. 0) then
              write(*,"(/,' This is an ionic system with net charge',
     &          f10.4)") chanet
            else
              write(*,"(/,' This is an anionic system with net charge',
     &          f10.4)") chanet
            end if
          else if(docc .lt. 1.d-2)then
            write(*,"(/,' Warning! Strange occupation: ',f10.4)")sumocc
            write(*,"(/,' Please check your AIM results carefully.')")
          else
            write(*,"(/,' Error! Strange occupation: ',f10.4)")sumocc
            goto 9910
          end if
        case("3")
          write(*,"(///,' Occupations are multiplied by 2.0...')")
          ifc4=2
          chanet=dble(nchar-iecp)-sumocc*dble(ifc4)
          write(*,"(/,4x,
     *    '#Electron        =',f10.4,/,4x,
     *    'Modified Sum_Occ =',f10.4,/,4x,
     *    '#Core Electron   =',f10.4,/,4x,
     *    'Net Charge       =',f10.4,/)")
     *    dble(nchar),sumocc*dble(ifc4),dble(iecp),chanet
c--- for Q-Chem
          if(iprog .eq. 0)write(*,"(
     *    ' *** WARNING ***',/,
     *    '  There is a BUG in Q-Chem RO-SCF. In this case, please',
     *    ' correct the',/,
     *    '  occupation numbers of singly occupied MOs manually.')")
        case default
          write(*,"(/,' Unknown reason. Please report the problem.')")
          goto 9910
      end select
      call xcontinue
      ierr=0

9910  return
      end

c-----------------------------------------------------------------------
c---  define file names
c-----------------------------------------------------------------------
      subroutine filename(imod,fmdn,fwfn,fwfx,fnbo)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*57 fwfn,fwfx,fnbo,fmod(2)
      character*64 fmdn
      character*7 exten(8)
      data exten/
     * '.mol   ','.MOL   ','.mold  ','.MOLD  ','.molden','.MOLDEN',
     * '.gab   ','.GAB   '/

      write(*,"(///)")
100   write(*,"(' Type in the MOLDEN/GABEDIT file name within 50',
     -' characters:',/,
     &' (extension mol/mold/molden/gab can be omitted;',
     -' default: MOLDEN)',/,
     &' > ',$)")
      read(*,"(a50)")fmod(1)(:)
      lstr=nonspace(fmod(1)(:))
      lend=LEN_TRIM(fmod(1)(:))
      if(lend.eq.0)then                 ! use default file name
        lstr=1
        lend=6
        fmod(1)(1:6)='MOLDEN'
      end if
      open(imod,file=fmod(1)(lstr:lend),status='old',err=110)
      iinp=1
      goto 300
110   if(fmod(1)(lend:lend).eq.'.')lend=lend-1
      iinp=2
      do i=1,8
        fmod(2)(:)=fmod(1)(lstr:lend)//trim(exten(i))
        open(imod,file=fmod(2)(:),status='old',err=120)
        goto 300
120     continue
      end do
      write(*,"(//,
     &  ' ### Wrong! These MOLDEN/GABEDIT files do not exist!')")
      write(*,"(1x,a)")fmod(1)
      do i=1,8
        write(*,"(1x,a)")fmod(1)(lstr:lend)//trim(exten(i))
      end do
      write(*,"(/,' Please try again.',/)")
      goto 100

300   write(*,"(/,' The MOLDEN/GABEDIT file ',a,' has been found.',/,
     &  1x,77('_'),/)") trim(fmod(iinp))
c---  define the *.wfn/wfx/47 file name
      lend2=index(fmod(iinp),'.',.true.)
      if(lend2 .gt. 1) lend = lend2-1
      fmdn=fmod(iinp)(lstr:lend)//'_new.molden'
      fwfn=fmod(iinp)(lstr:lend)//'.wfn'
      fwfx=fmod(iinp)(lstr:lend)//'.wfx'
      fnbo=fmod(iinp)(lstr:lend)//'.47'

      return
      end

c-----------------------------------------------------------------------
c---  make sure that iprog matches with lsph
c-----------------------------------------------------------------------
      subroutine chkbstyp(lsph,iprog,MaxL,ierr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      ierr=0
      if(lsph.eq.0 .and. MaxL.gt.1 .and. iprog.eq.1)then
c--- orca: spherical b.s. is used; for Cartesian b.s. (in a future
c--- version?), you should do some tests.
        write(*,
     *"(' ### Wrong! ORCA does not use Cartesian b.s.!')")
        ierr=1
      else if(lsph.ne.0 .and. MaxL.gt.1 .and. iprog.eq.2)then
c--- cfour: Cartesian b.s. is used; for spherical b.s. (in a future
c--- version?), you should do some tests.
        write(*,
     *"(' ### Wrong! CFOUR does not print MOs in spherical b.s.!')")
        ierr=1
      else if(lsph.ne.0 .and. MaxL.gt.1 .and. iprog.eq.3)then
c--- turbomole: Cartesian b.s. is used; for spherical b.s. (in a future
c--- version?), you should do some tests.
        write(*,
     *"(' ### Wrong! TURBOMOLE does not print MOs in spherical b.s.!')")
        ierr=1
      else if(lsph.ne.0 .and. MaxL.gt.1 .and. iprog.eq.4)then
c--- jaguar: Cartesian b.s. is used; for spherical b.s. (in a future
c--- version?), you should do some tests.
        write(*,
     *"(' ### Wrong! Jaguar does not print MOs in spherical b.s.!')")
        ierr=1
      else if(lsph.ne.0 .and. MaxL.gt.1 .and. iprog.eq.5)then
c--- aces2: Cartesian b.s. is used; for spherical b.s. (in a future
c--- version?), you should do some tests.
        write(*,
     *"(' ### Wrong! ACES2 does not print MOs in spherical b.s.!')")
        ierr=1
      end if

      return
      end

c-----------------------------------------------------------------------
c--- print title
c-----------------------------------------------------------------------
      subroutine writitle(iwfn,fwfn,ver,dt)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*57 fwfn
      character*10 dt
      character*5 ver
      character*50 texdate

      OPEN(iwfn,FILE=fwfn)
      rewind(iwfn)

c--- if fdate doesn't work, just use this line
c      write(iwfn,"(' Molden2AIM, Version ',a5,' (',a10,')')")ver,dt
c---
      call fdate(texdate)
      call trulen(texdate,L1,L2,length)
      write(iwfn,"(' Molden2AIM, Version ',a5,' (',a10,')',11x,
     *'Time: ',a24)")ver,dt,texdate(L1:L2)
c---
      return
      end

c-----------------------------------------------------------------------
c--- print head
c-----------------------------------------------------------------------
      subroutine headprt(ver,dt)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*10 dt
      character*5 ver

      write(*,"(//,1x,77('*'),/
     *31x,            '*  Molden2AIM  *',/,
     *26x,       'Version ',a5,',  ',a10,/,
     * 6x,'It converts the format from MOLDEN to AIM-WFN, AIM-WFX, ',
     *'and NBO-47.',/,1x,77('*'),/)")ver,dt
      return
      end

c-----------------------------------------------------------------------
c--- print supporting information
c-----------------------------------------------------------------------
      subroutine SuppInf
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      write(*,"(
     &' Supported programs:',/,
     &'  1) MOLPRO',/,
     &'  2) MOLCAS (for Cart. functions, insert [PROGRAM] MOLCAS into',
     -    ' MOLDEN file)',/,
     &'  3) deMon2k',/,
     &'  4) Q-Chem (spherical SPDF or Cartesian SPD basis functions)',/,
     &'  5) CFour (fix reorderdf.F, and insert [PROGRAM] CFOUR into',
     -    ' MOLDEN file)',/,
     &'  6) Turbomole (insert [PROGRAM] TURBOMOLE into MOLDEN file)',/,
     &'  7) ORCA (insert [PROGRAM] ORCA into MOLDEN file)',/,
     &'  8) Columbus (Natural orb. from MCSCF or CI with Cartesian',
     -    ' SPDF functions;',/,
     &'     thanks to Dr. Marat Talipov for testing)',/,
     &'  9) Priroda (thanks to Dr. Evgeniy Pankratyev for testing)',/,
     &' 10) Dalton (> 2013; HF/DFT/MP2/MCSCF with spherical',
     -    ' functions)',/,
     &' 11) TeraChem (SPDF basis functions)',/,
     &' 12) ACES-II 2.9 (fix reorder.F, and insert [PROGRAM] ACES2',
     -    ' into MOLDEN file)',/,
     &' 13) NWChem (using JANPA/nwchem2molden to generate MOLDEN file)'
     -    ,/,
     &' 14) BDF (thanks to Dr. Bingbing Suo for testing)',/,
     &' 15) PSI4 (spherical functions only; insert [PROGRAM] PSI4 into',
     -    ' MOLDEN file)',/,
     &' 16) CADPAC',/,
     &' 17) MRCC (for Cart. functions, insert [PROGRAM] MRCC into',
     -    ' MOLDEN file)',/,
     &' 18) NBO6 (> May.2014, insert [PROGRAM] NBO6 into',
     -    ' MOLDEN file)',/,
     &' 19) Molden (the Molden program can read MOs from the output',
     -    ' file of some',/,
     &'     QC programs, and save a MOLDEN file)',/,
     &' 20) Gabedit (the GAB file is compatible)',/,
     &' 21) MultiWFN (it can read the fchk file of Gaussian and',
     -    ' Q-Chem, and save',/,
     &'     a MOLDEN file)',/,
     &' 22) PySCF'
     &)")

      write(*,"(/,
     &' Programs to be tested:      1) NRLMOL     2) SeqQuest   ',
     &'3) StoBe')")

      write(*,"(/,
     &' Unsupported programs:       1) ADF        2) Jaguar')")

      call xcontinue

      return
      end

c-----------------------------------------------------------------------
c---  generate a standard Molden file with Cartrsian basis functions.
c-----------------------------------------------------------------------
      subroutine genmdn(fmdn,inmd,iatm,igto,imol,imo0,icor,ver,dt,nat,
     &  nmotot,ncarmo,ngc,ifc4,iecp,tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      character*5 ver
      character*10 dt
      character*50 texdate
      character*64 fmdn
      character*100 tmp

      OPEN(inmd,FILE=fmdn)
      rewind(inmd)

c---  title
      write(inmd,"('[Molden Format]')")
      write(inmd,"('[Title]')")
c     if fdate doesn't work, just use this line
c      write(inmd,"(' Molden2AIM, Version ',a5,' (',a10,')')")ver,dt
c
      call fdate(texdate)
      call trulen(texdate,L1,L2,length)
      write(inmd,"(' Molden2AIM, Version ',a5,' (',a10,')',11x,
     *'Time: ',a24)")ver,dt,texdate(L1:L2)
      write(inmd,*)

c---  coordinates
      rewind(iatm)
      read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
      if(iu .eq. 0) then
        write(inmd,"('[Atoms] Angs')")
      else
        write(inmd,"('[Atoms] AU')")
      end if

      do i=1,nat
        read(iatm,"(100a)")tmp
        write(inmd,"(100a)")trim(tmp)
      end do

c     #core
      if(iecp .gt. 0)then
cooo        write(inmd,"('[CORE]')")
cooo        rewind(icor)
cooo        do i=1,nat
cooo          read(icor,*) iz, j
cooo          if(j .gt. 0) write(inmd,"(i5,' : ',i5)") i,j
cooo        end do
        write(inmd,"('[PSEUDO]')")
        rewind(icor)
        do i=1,nat
          read(icor,*) iz, j
          call ElemZA(1,tmp,iz,tmp)
          write(inmd,"(a3,1x,2i6)") tmp(1:3), i, iz-j
        end do
      end if

c     the blank line before [GTO] is not allowed by MOLDEN!!!
ccc      write(inmd,*)

c---  basis functions
      rewind(igto)
      write(inmd,"('[GTO]')")
200   read(igto,"(100a)",end=300)tmp
      if(Len_trim(tmp) .eq. 0) goto 200
      if(index(tmp,' E 0').ne.0)then
        write(inmd,*)
      else
        write(inmd,"(100a)")trim(tmp)
      end if
      goto 200
300   write(inmd,*)

c---  MO in Cartesian basis functions
      rewind(imol)
      rewind(imo0)
      write(inmd,"('[MO]')")
      do i=1,nmotot
c       read "Sym=", "Ene=", "Spin=", and "Occup=" from imo0
c       Gabedit doesn't recognize UPPERCASE keywords!
600     read(imo0,"(100a)")tmp
        j=index(tmp,'=')
        if(j.ne.0)then
          call charl2u(tmp)
c         Occup=
          if(index(tmp(1:j-1),'OCCUP').ne.0)then
            read(tmp(j+1:),*)x
            write(inmd,"(' Occup=',f18.8)")x*dble(ifc4)
c         Ene=
          else if(index(tmp(1:j-1),'ENE').ne.0)then
c           in MOLDEN by ACES2-F/TeraChem, there may be " Ene=   ********" or a huge value
            x = 0.d0
            if(index(tmp(j+1:),'***') .eq. 0) then
              read(tmp(j+1:),*)x
              x = sign(min(abs(x), 1.d6), x)
            end if
            write(inmd,"(' Ene=',f20.8)")x
c         Sym=
          else if(index(tmp(1:j-1),'SYM').ne.0)then
            write(inmd,"(' Sym=',a)")trim(tmp(j+1:))
c         Spin=
          else if(index(tmp(1:j-1),'SPIN').ne.0)then
            if(index(tmp(j+1:),'ALPHA').ne.0)then
              write(inmd,"(' Spin= Alpha')")
            else
              write(inmd,"(' Spin= Beta')")
            end if
          else
            write(inmd,"(100a)")trim(tmp)
          end if

          goto 600
        end if

        do j=1,ncarmo-1
          read(imo0,*)
        end do
c       read MO coefficients from imol
        read(imol,*)
        read(imol,*)
        do j=1,ngc
          read(imol,*)idx,cf
          write(inmd,"(i5,f20.10)")idx,cf*scalmo(j)
        end do
      end do
      write(inmd,*)

      write(*,"(//,
     *'  A new Molden file is generated successfully!',/,
     *'  File Name = ',a)")trim(fmdn)

      return
      end

c-----------------------------------------------------------------------
c---  print information at the final step for wfn
c-----------------------------------------------------------------------
      subroutine finalwfn(fwfn,iecp,MaxL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*57 fwfn

      write(*,"(//,
     &'  A WFN file is generated successfully!',/,
     &'  File Name = ',a)")trim(fwfn)
      if(iecp .gt. 0)then
        write(*,"(/,2x,
     &'Because of PP (ECP or MCP), please use',/,3x,
     &'MultiWFN 3.2.1 or higher version',/)")
      else if(MaxL .lt. 4)then
        write(*,"(/,2x,
     &'Please use',/,3x,
     &'AIM2000, AIMALL, AIMPAC, AIMPAC2, AIM-UC, CheckDen, Critic2, ',
     -'DensToolKit,',/,3x,
     &'DGrid, MORPHY, MultiWFN, ORBKIT, PAMoC, ProMolden, TopChem, ',
     -'TopMoD,',/,3x,
     &'or XAIM',/)")
      else
        write(*,"(/,2x,
     &'G-functions are found! Please use',/,3x,
     &'AIM2000 (Ver. 2013), AIMALL, AIM-UC, Critic2, DGrid, MultiWFN, ',
     -'ORBKIT,',/,3x,
     &'or TopChem',/)")
      end if
      write(*,"('  to analyse the electron density distribution.')")
      if(iecp .gt. 0) write(*,"(/,9x,
     &'>>> Please consult MultiWFN manual (sec. 5.7) for details <<<')")

      return
      end

c-----------------------------------------------------------------------
c---  print information at the final step for wfx
c-----------------------------------------------------------------------
      subroutine finalwfx(fwfn,iecp,iunknw,MaxL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*57 fwfn

      write(*,"(//,
     &'  A WFX file is generated successfully!',/,
     &'  File Name = ',a)")trim(fwfn)
c     with ECP
      if(iecp .gt. 0) then
        if(MaxL .lt. 4)then
          write(*,"(/,2x,
     &  'ECPs are found! Please use',/,3x,
     &  'AIMALL, Critic2, DensToolKit, MultiWFN, or ORBKIT',/)")
        else
          write(*,"(/,2x,
     &  'ECPs and G-functions are found! Please use',/,3x,
     &  'AIMALL, Critic2, MultiWFN, or ORBKIT',/)")
        end if
c     without ECP
      else
        if(MaxL .lt. 4)then
          write(*,"(/,2x,
     &  'Please use',/,3x,
     &  'AIMALL, Critic2, DensToolKit, GPView, MultiWFN, or ORBKIT',/)")
        else
          write(*,"(/,2x,
     &  'G-functions are found! Please use',/,3x,
     &  'AIMALL, Critic2, GPView, MultiWFN, or ORBKIT',/)")
        end if
      end if
      write(*,"('  to analyse the electron density distribution.')")
      if(iunknw .eq. 0) then
        write(*,"(//,6x,65('-'),/, 6x,'>>>',
     -    ' Please correct the UNKNOWN terms in the WFX file manually ',
     -    '<<<',/, 6x,65('-'),/)")
      else
        write(*,"(//,6x,65('-'),/, 6x,'>>>',
     -    ' Please modify Energy and Virial Ratio in WFX if necessary ',
     -    '<<<',/, 6x,65('-'),/)")
      end if

      return
      end

c-----------------------------------------------------------------------
c--- print information at the final step for nbo's 47 file
c-----------------------------------------------------------------------
      subroutine finalnbo(fnbo,MaxL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*57 fnbo

      write(*,"(//,
     &'  A NBO 47 file is generated successfully!',/,
     &'  File Name = ',a)")trim(fnbo)

      if(MaxL .gt. 3) write(*,"(/,
     &' Warning: G-functions are not fully supported by NBO 3.0.',/,
     &' Delete the $CONTRACT data block manually if NBO 3.0 is used.')")

coooc     IZ(2) will be modified automatically in future.
cooo      if(iecp .gt. 0) write(*,"(/,
cooo     &' Since ECP is used, IZ(2) in $COORD has to be corrected',
cooo     -' manually. For example,',//,
cooo     &' $COORD',/,
cooo     &' AuH',/,
cooo     &'     79    19       0.000000       0.000000       0.021250',/,
cooo     &'           ~~ <---- IZ(2) = IZ(1) - #core electrons = 79 - 60',/,
cooo     &'      1     1       0.000000       0.000000      -1.678750')")

      return
      end

c-----------------------------------------------------------------------
c--- A new version of the subroutine checkcar for shortened MO arrays.
c--- Count the number of basis functions from MO, which can be used to
c--- judge cartesian/spherical basis functions.
c-----------------------------------------------------------------------
      subroutine checkcar2(nc,ishort,ifmo,tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp

      imod=44
      nc=0
      ifmo=1
      ishort=0
      maxnc=0
      iold=0

c--- count the number of CGTO
      rewind(imod)

500   read(imod,"(100a)",end=550)tmp
      call charl2u(tmp)
      if(index(tmp,'[MO]').ne.0) goto 600
      goto 500

550   write(*,*)"*** Wrong! [MO] can not be found!"
      ifmo=0
      return

600   read(imod,"(100a)",end=9999)tmp
      if(len_trim(tmp).eq.0) goto 600
c      call charl2u(tmp)
      if(index(tmp,'=').ne.0) goto 600
      if(index(tmp,'[').ne.0) goto 9999

      nc=0
610   read(tmp,*)inew
      nc=nc+1
      maxnc=max(maxnc,inew)
620   read(imod,"(100a)",end=9990)tmp
      if(len_trim(tmp).eq.0) goto 620
      if(index(tmp,'=').ne.0)then
        if(nc .lt. maxnc) ishort=1
        goto 600
      end if
      if(index(tmp,'[').ne.0) goto 9990
      goto 610

9990  if(nc .lt. maxnc) ishort=1
9999  nc=maxnc

      return
      end

cc-----------------------------------------------------------------------
cc--- count the number of basis functions from MO, which can be used to
cc--- judge Cartesian/spherical basis functions.
cc-----------------------------------------------------------------------
c      subroutine checkcar(nc,ifmo,tmp)
c      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c      character*100 tmp
c
c      imod=44
c      nc=0
c      ifmo=1
c
cc--- Dalton prints spherical basis functions by default in the MOLDEN
cc--- file, but the keywords [5d], [7f], and [9g] are not specified.
cc      rewind(imod)
cc
cc100   read(imod,"(100a)",end=200)tmp
cc      call charl2u(tmp)
cc      if(index(tmp,'[').ne.0 .and. index(tmp,']').ne.0) then
cc        if( index(tmp,'[5D').ne.0 .or. index(tmp,'[7F').ne.0 .or.
cc     *      index(tmp,'[9G').ne.0 ) goto 9999
cc      end if
cc      goto 100
cc200   continue
c
cc--- count the number of CGTO
c      rewind(imod)
c
c500   read(imod,"(100a)",end=550)tmp
c      call charl2u(tmp)
c      if(index(tmp,'[MO]').ne.0) goto 600
c      goto 500
c
c550   write(*,*)"*** Wrong! [MO] can not be found!"
c      ifmo=0
c      return
c
c600   read(imod,"(100a)",end=9999)tmp
c      call charl2u(tmp)
c      if(index(tmp,'OCCUP').ne.0) goto 700
c      goto 600
c
c700   read(imod,"(100a)",end=9999)tmp
cc      call charl2u(tmp)
c      if(index(tmp,'[').ne.0 .or. index(tmp,'=').ne.0 .or.
c     *   len_trim(tmp).eq.0) then
c        goto 9999
c      else
c        nc=nc+1
c        goto 700
c      end if
c
c9999  continue
c
c      return
c      end

c-----------------------------------------------------------------------
c--- write MO.s to the *.wfn file
c-----------------------------------------------------------------------
      subroutine writemol(iwfn,imol,nmo,ng,ngc,tolocc,ifc4,tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      character*100 tmp

c--- normalization factor
      do i=1,ng
        cn(i)=fnorm_lmn(expg(i),ityp(i))
      end do

      rewind(imol)
      do i=1,nmo
c       in MOLDEN by ACES2-F/TeraChem, there may be " Ene=   ********" or a huge value
        occ=0.d0
        ene=0.d0
        read(imol,"(a100)") tmp
        is=index(tmp,'=')
        if(index(tmp(is+1:),'***') .eq. 0) read(tmp(is+1:),*) occ
        read(imol,"(a100)") tmp
        is=index(tmp,'=')
        if(index(tmp(is+1:),'***') .eq. 0) then
          read(tmp(is+1:),*) ene
          ene = sign(min(abs(ene), 1.d6), ene)
        end if
cooo        read(imol,*)tmp,occ
cooo        read(imol,*)tmp,eng
        do j=1,ngc
          read(imol,*)ingc,cfmo(j)
          cfmo(j)=cfmo(j)*scalmo(j)
        end do
        if(abs(occ) .ge. tolocc)then
          if(abs(eng).lt.9999.d0)then
            write(iwfn,1000)i,occ*dble(ifc4),eng
          else
            write(iwfn,1100)i,occ*dble(ifc4),eng
          end if
c---      N*cgto*cmo
          write(iwfn,"(5d16.8)")
     *      (cn(j)*conf(j)*cfmo(icmo(j)),j=1,ng)
        end if
      end do

1000  format("MO",i5,5x,"MO 0.0",8x,"OCC NO =",f13.7,"  ORB. ENERGY =",
     *f12.6)
1100  format("MO",i5,5x,"MO 0.0",8x,"OCC NO =",f13.7,"  ORB. ENERGY =",
     *f12.4)

      return
      end

c-----------------------------------------------------------------------
c---  Save a wavefunction file in wfx format.
c
c     Note:
c
c     1. Fortran D (or d) descriptor for numbers is NOT allowed.
c
c     2. All data must be in atomic units.
c
c     3. Comment lines start with the # character must NOT be used inside
c        data sections, i.e., between opening and closing tags.
c
c     4. MO should be in the order doubly, singly Alpha, singly Beta.
c        For RO-SCF, this means all doubly occupied MOs, then all singly
c        occupied Alpha MOs.
c        For U-SCF or post-SCF, this means all Alpha MOs then all Beta
c        MOs.
c        Within a block of MOs, the SCF MOs should be in the order of
c        increasing MO energy
c        Within a block of post-SCF natural MOs, they should be in the
c        order of decreasing occupancy.
c
c        >>>>>>>>>>>>>>>>>>>>>>>>>> Not considered at present!
c
c     5. Non-nuclear attractors can be added to the .wfx file as nuclei
c        with atomic number 0, nuclear charge 0.0 and with names begin-
c        ning with NNA (e.g., NNA8).
c        and
c        Ghost atoms can be added to the .wfx file as nuclei with atomic
c        number 0, nuclear charge 0.0 and with names beginning with Bq
c        (e.g., Bq12).  The coordinates of ghost nuclei must appear in
c        the appropriate position of the <Nuclear Cartesian Coordinates>
c        section of the .wfx file.
c
c        >>>>>>>>>>>>>>>>>>>>>>>>>> Not considered at present!
c
c-----------------------------------------------------------------------
      subroutine genwfx(iatm,igto,imol,ispn,icor,iedf,iwfx,fwfx,ver,dt,
     &  nat,nmotot,nmo,chanet,tolocc,ntote,ncar,ncarc,nedf,iecp,ifc4,
     &  ifspin,ifbeta,iunknw,ctmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter (maxza=120,au2ang=0.529177249d0)
      parameter (maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      character*57 fwfx
      character*10 dt
      character*5 ver
      character*100 ctmp
      logical prtspn

      ncore = 0

      OPEN(iwfx,FILE=fwfx)
      rewind(iwfx)

c--- if fdate doesn't work, just use this line
c      write(iwfx,"(' Molden2AIM, Version ',a5,' (',a10,')')")ver,dt
c---
      call fdate(ctmp)
      call trulen(ctmp,L1,L2,length)

c     Title
      call wfxlab(iwfx,0,"Title")
      write(iwfx,"(' Molden2AIM, Version ',a5,' (',a10,')',11x,
     *'Time: ',a24)")ver,dt,ctmp(L1:L2)
      call wfxlab(iwfx,1,"Title")

c     Keywords
      call wfxlab(iwfx,0,"Keywords")
      write(iwfx,"(' GTO')")
      call wfxlab(iwfx,1,"Keywords")

c     Number of Nuclei
      call wfxlab(iwfx,0,"Number of Nuclei")
      write(iwfx,"(i8)")nat
      call wfxlab(iwfx,1,"Number of Nuclei")

c     Number of Occupied Molecular Orbitals
      call wfxlab(iwfx,0,"Number of Occupied Molecular Orbitals")
      write(iwfx,"(i8)")nmo
      call wfxlab(iwfx,1,"Number of Occupied Molecular Orbitals")

c     Number of Perturbations
      call wfxlab(iwfx,0,"Number of Perturbations")
      write(iwfx,"(i8)")0
      call wfxlab(iwfx,1,"Number of Perturbations")

c     Net Charge
      call wfxlab(iwfx,0,"Net Charge")
      write(iwfx,"(i8)")nint(chanet)
      call wfxlab(iwfx,1,"Net Charge")

c     Number of Electrons (Core Electrons by ECP are excluded)
      call wfxlab(iwfx,0,"Number of Electrons")
      write(iwfx,"(i8)")ntote
      call wfxlab(iwfx,1,"Number of Electrons")

c     it works only when Beta exists
      prtspn=.false.
      if(ifspin .eq. 1 .and. ifbeta .eq. 1) then
        elea = 0.d0
        eleb = 0.d0
        rewind(ispn)
        do i=1,nmo
          read(ispn,"(a42)")ctmp
          read(ctmp(1:2),*)ix
          read(ctmp(3:22),*)x
          if(ix .eq. 1) then
            elea = elea + x*dble(ifc4)
          else if(ix .eq. 2) then
            eleb = eleb + x*dble(ifc4)
          end if
        end do
        if(abs(elea+eleb-dble(ntote)) .lt. 0.01d0 .and.
     &     abs(elea-dble(nint(elea))) .lt. 0.01d0 .and.
     &     abs(eleb-dble(nint(eleb))) .lt. 0.01d0) prtspn = .true.
      end if

      if(prtspn) then
        nelea = nint(elea)
        neleb = nint(eleb)
        MS = nelea - neleb + 1
      else
c       Read in Spin Multiplicity, Numbers of Alpha and Beta electrons
        do while(.true.)
          write(*,"(/,'  Type in the Spin Multiplicity:',/,
     &    '  (default: 1 for even- and 2 for odd-number of electron',
     &    ' system)',/,' > ',$)")
          read(*,"(a10)",err=50) ctmp
          if(len_trim(ctmp(1:10)) .eq. 0) then
          	MS = 1
          	if(mod(ntote,2) .eq. 1) MS = 2
          else
            read(ctmp(1:10),*,err=50) MS
          end if

          if(MS .lt. 1 .or. MS .gt. ntote+1) then
            write(*,"(/,'   MS is out of range! Try again.')")
            cycle
          else if(mod(ntote,2) .eq. 0 .and. mod(MS,2) .eq. 0) then
            write(*,"(/,'   MS must be an odd number! Try again.')")
            cycle
          else if(mod(ntote,2) .eq. 1 .and. mod(MS,2) .eq. 1) then
            write(*,"(/,'   MS must be an even number! Try again.')")
            cycle
          else
            exit
          end if

50        write(*,"(/,'   Error when reading MS! Try again.')")
          cycle
        end do
        neleb = (ntote + 1 - MS) / 2
        nelea = ntote - neleb
      end if
      write(*,"(/,'  Spin Multiplicity:', i4)") MS

c     Number of Alpha Electrons
      call wfxlab(iwfx,0,"Number of Alpha Electrons")
      write(iwfx,"(i8)") nelea
      call wfxlab(iwfx,1,"Number of Alpha Electrons")

c     Number of Beta Electrons
      call wfxlab(iwfx,0,"Number of Beta Electrons")
      write(iwfx,"(i8)") neleb
      call wfxlab(iwfx,1,"Number of Beta Electrons")

c     Electronic Spin Multiplicity (optional)
      call wfxlab(iwfx,0,"Electronic Spin Multiplicity")
      write(iwfx,"(i8)") MS
      call wfxlab(iwfx,1,"Electronic Spin Multiplicity")

c     Number of Core Electrons
      call wfxlab(iwfx,0,"Number of Core Electrons")
      write(iwfx,"(i8)")iecp
      call wfxlab(iwfx,1,"Number of Core Electrons")

c     Nuclear Names
      call wfxlab(iwfx,0,"Nuclear Names")
      rewind(iatm)
      read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
      do i=1,nat
        call CClear(100,ctmp)
        read(iatm,*)ctmp(1:3),j,ix
        write(ctmp(11:100),*)i
        call trulen(ctmp(11:100),len2,len3,len1)
        if(ix.gt.0 .and. ix.le.maxza) call ElemZA(1,ctmp,ix,ctmp)
        len1=len_trim(ctmp(1:3))
        write(iwfx,"(a)")ctmp(1:len1)//ctmp(len2+10:len3+10)
      end do
      call wfxlab(iwfx,1,"Nuclear Names")

c     Atomic Numbers (Z)
      call wfxlab(iwfx,0,"Atomic Numbers")
      rewind(iatm)
      read(iatm,*)
      do i=1,nat
        read(iatm,*)ctmp,j,ix
        write(iwfx,"(i8)")ix
      end do
      call wfxlab(iwfx,1,"Atomic Numbers")

c     Nuclear Charges (Z-#core)
      call wfxlab(iwfx,0,"Nuclear Charges")
      rewind(iatm)
      rewind(icor)
      read(iatm,*)
      do i=1,nat
        read(iatm,*)ctmp,j,ix
        if(iecp .gt. 0) read(icor,*) iz, ncore
        write(iwfx,"(e21.12e3)")dble(ix-ncore)
      end do
      call wfxlab(iwfx,1,"Nuclear Charges")

c     Nuclear Cartesian Coordinates (in a.u.)
      call wfxlab(iwfx,0,"Nuclear Cartesian Coordinates")
      fc=1.d0
      rewind(iatm)
      read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
      if(iu.eq.0)fc=1.d0/au2ang
      do i=1,nat
        read(iatm,*)ctmp,ia,iz,x,y,z
        write(iwfx,"(3e21.12e3)")x*fc,y*fc,z*fc
      end do
      call wfxlab(iwfx,1,"Nuclear Cartesian Coordinates")

c     Number of Primitives
      call wfxlab(iwfx,0,"Number of Primitives")
      write(iwfx,"(i8)")ncar
      call wfxlab(iwfx,1,"Number of Primitives")

c     print basis functions
      call writecnt(iwfx,1,igto,imol,ncar)

c     <<<<<<<<<<<<<<<<<< ECP >>>>>>>>>>>>>>>>>>
      if(iecp .gt. 0)then
        call wfxlab(iwfx,0,"Additional Electron Density Function (EDF)")
c         Number of EDF Primitives
          call wfxlab(iwfx,0,"Number of EDF Primitives")
          write(iwfx,"(i8)")nedf
          call wfxlab(iwfx,1,"Number of EDF Primitives")
c         EDF Primitive Centers
          call wfxlab(iwfx,0,"EDF Primitive Centers")
          rewind(iedf)
          do i=1,nedf
            read(iedf,"(i5)") ix
            write(iwfx,"(i8)",advance='no') ix
            if(mod(i,5) .eq. 0) write(iwfx,*)
          end do
          if(mod(nedf,5) .ne. 0) write(iwfx,*)
          call wfxlab(iwfx,1,"EDF Primitive Centers")
c         EDF Primitive Types
          call wfxlab(iwfx,0,"EDF Primitive Types")
          write(iwfx,"(5i8)") (1, i=1, nedf)
          call wfxlab(iwfx,1,"EDF Primitive Types")
c         EDF Primitive Exponents
          call wfxlab(iwfx,0,"EDF Primitive Exponents")
          rewind(iedf)
          do i=1,nedf
            read(iedf,"(5x,e21.12e3)") x
            write(iwfx,"(e21.12e3)",advance='no') x
            if(mod(i,5) .eq. 0) write(iwfx,*)
          end do
          if(mod(nedf,5) .ne. 0) write(iwfx,*)
          call wfxlab(iwfx,1,"EDF Primitive Exponents")
c         EDF Primitive Coefficients
          call wfxlab(iwfx,0,"EDF Primitive Coefficients")
          rewind(iedf)
          do i=1,nedf
            read(iedf,"(26x,e21.12e3)") x
            write(iwfx,"(e21.12e3)",advance='no') x
            if(mod(i,5) .eq. 0) write(iwfx,*)
          end do
          if(mod(nedf,5) .ne. 0) write(iwfx,*)
          call wfxlab(iwfx,1,"EDF Primitive Coefficients")
        call wfxlab(iwfx,1,"Additional Electron Density Function (EDF)")
      end if

c     Molecular Orbital Occupation Numbers
      call wfxlab(iwfx,0,"Molecular Orbital Occupation Numbers")
      rewind(ispn)
      do i=1,nmo
        read(ispn,"(a42)")ctmp
        read(ctmp(3:22),*)x
        write(iwfx,"(e21.12e3)")x*dble(ifc4)
      end do
      call wfxlab(iwfx,1,"Molecular Orbital Occupation Numbers")

c     Molecular Orbital Energies
      call wfxlab(iwfx,0,"Molecular Orbital Energies")
      rewind(ispn)
      do i=1,nmo
        read(ispn,"(a42)")ctmp
        read(ctmp(23:42),*)x
        write(iwfx,"(e21.12e3)")x
      end do
      call wfxlab(iwfx,1,"Molecular Orbital Energies")

c     Molecular Orbital Spin Types
      call wfxlab(iwfx,0,"Molecular Orbital Spin Types")
      rewind(ispn)
      do i=1,nmo
        if(prtspn) then
          read(ispn,"(a42)")ctmp
          read(ctmp(1:2),*)ix
          if(ix .eq. 1) then
            write(iwfx,"(' Alpha')")
          else if(ix .eq. 2) then
            write(iwfx,"(' Beta')")
          end if
        else
          write(iwfx,"(' Alpha and Beta')")
        end if
      end do
      call wfxlab(iwfx,1,"Molecular Orbital Spin Types")

c     normalization factor
      do i=1,ncar
        cn(i)=fnorm_lmn(expg(i),ityp(i))
      end do

c     MO
      call wfxlab(iwfx,0,"Molecular Orbital Primitive Coefficients")
      rewind(imol)
      ix=0
      do i=1,nmotot
        read(imol,*)ctmp,occ
        read(imol,*)
        do j=1,ncarc
          read(imol,*)ingc,cfmo(j)
          cfmo(j)=cfmo(j)*scalmo(j)
        end do
        if(abs(occ) .ge. tolocc)then
          ix = ix + 1
c         MO Number
          call wfxlab(iwfx,0,"MO Number")
          write(iwfx,"(i8)")ix
          call wfxlab(iwfx,1,"MO Number")
c---      N*cgto*cmo
          write(iwfx,"(5e21.12e3)") (cn(j)*conf(j)*cfmo(icmo(j)),
     *      j=1,ncar)
        end if
      end do
      call wfxlab(iwfx,1,"Molecular Orbital Primitive Coefficients")

c     Energy = T + Vne + Vee + Vnn
      write(iwfx,"('# The total energy of the molecule.')")
      write(iwfx,"('# For HF and KSDFT, this is the SCF energy.')")
      write(iwfx,"('# For MP2, this is the MP2 total energy.')")
      write(iwfx,"('# For CCSD, this is the CCSD total energy.')")
      write(iwfx,"('# etc.')")
      call wfxlab(iwfx,0,"Energy = T + Vne + Vee + Vnn")
      if(iunknw .eq. 0) then
        write(iwfx,"(' UNKNOWN')")
      else
        write(iwfx,"(e21.12e3)") 0.d0
      end if
      call wfxlab(iwfx,1,"Energy = T + Vne + Vee + Vnn")

c     Virial Ratio (-V/T)
      call wfxlab(iwfx,0,"Virial Ratio (-V/T)")
      if(iunknw .eq. 0) then
        write(iwfx,"(' UNKNOWN')")
      else
        write(iwfx,"(e21.12e3)") 2.d0
      end if
      call wfxlab(iwfx,1,"Virial Ratio (-V/T)")

      return
      end

c-----------------------------------------------------------------------
c---  main subroutine of EDF library.
c-----------------------------------------------------------------------
      subroutine edfmain(icor,iedf,iecp,nat,nedf)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(MxEDF=40)
      dimension edfa(MxEDF),edfc(MxEDF)

      nedf = 0
      if(iecp .lt. 2) return

      pi=acos(-1.d0)
      alf=pi * 4.d0

      rewind(icor)
      rewind(iedf)

      write(*,"(/,'  Generate EDF data:')")
      do i=1,nat
        read(icor,*)iz,ncore
        if(ncore .gt. 0)then
          call EDFLIB(iz,ncore,nfun,edfa,edfc)    ! it's assumed that nfun <= 40

          if(nfun .gt. 0) then
            nedf = nedf + nfun
            acore = 0.d0
            do j=1, nfun
              write(iedf,"(i5,2e21.12e3)") i, edfa(j), edfc(j)
              x = sqrt(pi/edfa(j))
              acore = acore + edfc(j)*x*x*x
            end do
            write(*,"('  Iatm=',i4,', ZA=',i4,', NCore=',i4,', ACore=',
     &        f14.9,': EDF data from library')") i, iz, ncore, acore
          else if(ncore .gt. 0) then
c           Generate EDF using the tight core density function, ie.
c           alpha = 4pi, c = 8Ncore
c           It is good for small-core or medium-core ECP but worse for
c           large-core ECP. See Eq. 9 in JPCA 115, 12879 (2011).
            c=dble(8*ncore)
            nedf = nedf + 1
            write(iedf,"(i5,2e21.12e3)") i, alf, c
            x = sqrt(pi/alf)
            acore = c*x*x*x
            write(*,"('  Iatm=',i4,', ZA=',i4,', NCore=',i4,', ACore=',
     &        f14.9,': Tight Core Function')") i, iz, ncore, acore
          end if
        end if
      end do

      return
      end

c-----------------------------------------------------------------------
c---  wfx: print a label
c-----------------------------------------------------------------------
      subroutine wfxlab(iwfx,mode,label)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*(*) label

      if(mode .eq. 0) then
        write(iwfx,"('<',a,'>')")label
      else
        write(iwfx,"('</',a,'>')")label
      end if

      return
      end

c-----------------------------------------------------------------------
c---  calculate the normalization factor for GTO(l,m,n)
c---  it = 1,...,35
c---  Ordering type:
c---  S,P,D: MOLDEN, Gaussian, GAMESS, WFN, ...
c---  F: WFN (for MOLDEN and Gaussian, 14~19 are different)
c---  G: WFN, MOLDEN (not for Gaussian)
c-----------------------------------------------------------------------
      function fnorm_lmn(a,it)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      pi=acos(-1.d0)
      pi3=pi**3.d0

      select case(it)
        case(1)            ! 1S
          n1=3
          n2=3
          nf=1
        case(2:4)          ! 3P: x, y, z
          n1=7
          n2=5
          nf=1
        case(5:10)         ! 6D
          n1=11
          n2=7
          select case(it)
            case(5:7)        ! xx, yy, zz
              nf=9
            case(8:10)       ! xy, xz, yz
              nf=1
          end select
        case(11:20)        ! 10F
          n1=15
          n2=9
          select case(it)
            case(11:13)      ! xxx, yyy, zzz
              nf=225
            case(14:19)      ! xxy, xxz, yyz, xyy, xzz, yzz
              nf=9
            case(20)         ! xyz
              nf=1
          end select
        case(21:35)        ! 15G
          n1=19
          n2=11
          select case(it)
            case(21:23)      ! xxxx yyyy zzzz
              nf=11025
            case(24:29)      ! xxxy xxxz yyyx yyyz zzzx zzzy
              nf=225
            case(30:32)      ! xxyy xxzz yyzz
              nf=81
            case(33:35)      ! xxyz yyxz zzxy
              nf=9
          end select
cc<<<     Gaussian (subroutine pattml should also be modified)
c          select case(it)
c            case(21,25,35)               ! xxxx yyyy zzzz
c              nf=11025
c            case(22,24,26,29,33,34)      ! xxxy xxxz yyyx yyyz zzzx zzzy
c              nf=225
c            case(23,30,32)               ! xxyy xxzz yyzz
c              nf=81
c            case(27,28,31)               ! xxyz yyxz zzxy
c              nf=9
c          end select
cc>>>
      end select

c--- Normal^4 = 2^n1 * a^n2 / (pi^3 * nf)
c---   n1=3+4*(l+m+n)
c---   n2=3+2*(l+m+n)
c---   nf=[(2l-1)!!(2m-1)!!(2n-1)!!]^2
      f = (2.d0**dble(n1)) * (a**dble(n2)) / (pi3 * dble(nf))
      fnorm_lmn=sqrt(sqrt(f))

      return
      end

c-----------------------------------------------------------------------
c--- write atoms, coordinates, and basis functions to the *.wfn (mode=0)
c    or *.wfx (mode.ne.0) file
c-----------------------------------------------------------------------
      subroutine writecnt(iwfn,mode,igto,imol,npg)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      character*1 al
      character*10 tmp

      rewind(igto)
      rewind(imol)
      ipt1=0
      ipt2=0

      read(imol,*)tmp,occ
      read(imol,*)tmp,eng
100   read(igto,*,end=500)ic1
200   read(igto,*)al,np
      if(al.eq.'E'.and.np.eq.0)goto 100
      do i=1,np
        read(igto,*)expgc(i),confc(i)
      end do
      select case(al)
        case('S')
          nfun=1
          it=0
        case('P')
          nfun=3
          it=1
        case('D')
          nfun=6
          it=4
        case('F')
          nfun=10
          it=10
        case('G')
          nfun=15
          it=20
      end select
      do i=1,nfun
        ipt1=ipt2+1
        ipt2=ipt1+np-1
        it=it+1
        expg(ipt1:ipt2)=expgc(1:np)
        conf(ipt1:ipt2)=confc(1:np)
        icnt(ipt1:ipt2)=ic1
        do j=ipt1,ipt2
          if(it.ge.14.and.it.le.19)then
! f: xyy, xxy, xxz, xzz, yzz, yyz (MOLDEN or Gaussian-out) -->
!    xxy, xxz, yyz, xyy, xzz, yzz (Gaussian-WFN or GAMESS-WFN)
            ityp(j)=iorder(it)
          else
            ityp(j)=it
          end if
        end do
c--- read MO coeff. index
        read(imol,*)igc
        icmo(ipt1:ipt2)=igc
      end do
      goto 200

500   continue

      if(mode.eq.0)then
c       wfn
        write(iwfn,"('CENTRE ASSIGNMENTS  ',20i3)")(icnt(i),i=1,npg)
        write(iwfn,"('TYPE ASSIGNMENTS    ',20i3)")(ityp(i),i=1,npg)
        write(iwfn,"('EXPONENTS ',5d14.7)")(expg(i),i=1,npg)
      else
c       wfx
        call wfxlab(iwfn,0,"Primitive Centers")
        write(iwfn,"(5i20)")(icnt(i),i=1,npg)
        call wfxlab(iwfn,1,"Primitive Centers")
        call wfxlab(iwfn,0,"Primitive Types")
        write(iwfn,"(5i20)")(ityp(i),i=1,npg)
        call wfxlab(iwfn,1,"Primitive Types")
        call wfxlab(iwfn,0,"Primitive Exponents")
        write(iwfn,"(5e21.12e3)")(expg(i),i=1,npg)
        call wfxlab(iwfn,1,"Primitive Exponents")
      end if

      return
      end

c-----------------------------------------------------------------------
c--- reorder f-functions from MOLDEN to WFN.
c-----------------------------------------------------------------------
      function iorder(n)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      select case(n)
        case(14)
          iorder=17
        case(15)
          iorder=14
        case(16)
          iorder=15
        case(17)
          iorder=18
        case(18)
          iorder=19
        case(19)
          iorder=16
      end select

      return
      end

c-----------------------------------------------------------------------
c--- read an <ENTER> to continue
c-----------------------------------------------------------------------
      subroutine xcontinue
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      write(*,"(/,' Press <ENTER> to continue')")
      read(*,*)

      return
      end

c-----------------------------------------------------------------------
c--- read an <ENTER> and stop
c-----------------------------------------------------------------------
      subroutine estop
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      write(*,"(//,' Press <ENTER> to exit',/)")
      read(*,*)

      stop

      return
      end

c-----------------------------------------------------------------------
c--- print spin of MO
c    in ispn,    0: n.a.     1: alpha or alpha+beta    2: beta
c    in iwfn,    1: alpha    2: beta    3: alpha+beta
c-----------------------------------------------------------------------
      subroutine writespn(iwfn,ispn,ifbeta,NMO)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(ncol=40)
      dimension is(ncol)

      rewind(ispn)
      write(iwfn,"(//,' $MOSPIN $END')")

      nline=NMO/ncol
      nlast=mod(NMO,ncol)

      do j=1,ncol
        is(j)=3
      end do
      do i=1,nline
        if(ifbeta.eq.1) read(ispn,"(i2)")(is(j),j=1,ncol)
        write(iwfn,"(40i2)")is(1:ncol)
      end do

      if(nlast.gt.0)then
        if(ifbeta.eq.1) read(ispn,"(i2)")(is(j),j=1,nlast)
        write(iwfn,"(40i2)")is(1:nlast)
      end if
      write(iwfn,"(/)")

      return
      end

c-----------------------------------------------------------------------
c---  Mode = 0 : returns nuclear charge zchar for an element symbol "el"
c---             iza is not used.
c---    .ne. 0 : returns element symbol "el" for nuclear charge iza
c---             zchar is not used.
c-----------------------------------------------------------------------
      subroutine ElemZA(Mode,el,iza,zchar)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter (maxza=120)
      character*3 el,atomlib(maxza)
      data (atomlib(i),i=1,50) /
     1'H  ','HE ','LI ','BE ','B  ','C  ','N  ','O  ','F  ','NE ',
     2'NA ','MG ','AL ','SI ','P  ','S  ','CL ','AR ','K  ','CA ',
     3'SC ','TI ','V  ','CR ','MN ','FE ','CO ','NI ','CU ','ZN ',
     4'GA ','GE ','AS ','SE ','BR ','KR ','RB ','SR ','Y  ','ZR ',
     5'NB ','MO ','TC ','RU ','RH ','PD ','AG ','CD ','IN ','SN '/
      data (atomlib(i),i=51,100) /
     6'SB ','TE ','I  ','XE ','CS ','BA ','LA ','CE ','PR ','ND ',
     7'PM ','SM ','EU ','GD ','TB ','DY ','HO ','ER ','TM ','YB ',
     8'LU ','HF ','TA ','W  ','RE ','OS ','IR ','PT ','AU ','HG ',
     9'TL ','PB ','BI ','PO ','AT ','RN ','FR ','RA ','AC ','TH ',
     A'PA ','U  ','NP ','PU ','AM ','CM ','BK ','CF ','ES ','FM '/
      data (atomlib(i),i=101,maxza) /
     B'MD ','NO ','LR ','RF ','DB ','SG ','BH ','HS ','MT ','DS ',
     C'RG ','CN ','NH ','FL ','MC ','LV ','TS ','OG ','UUE','UBN'/
      save atomlib

      if (Mode .eq. 0) then

        call charl2u(el)
        zchar = 0.d0
        do i=1,maxza
          if(index(el,atomlib(i)) .ne. 0)then
            zchar = dble(i)
            exit
          end if
        end do

      else

        el = "???"
        if(iza .gt. 0 .and. iza .le. maxza) el = adjustl(atomlib(iza))
        call charu2l(el(2:3))

      end if

      return
      end

c-----------------------------------------------------------------------
c---  write coordinates to WFN.
c-----------------------------------------------------------------------
      subroutine writeatm(iwfn,iatm,icor,nat,iecp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter (maxza=120,au2ang=0.529177249d0)
      character*3 am

      ncore=0
      rewind(icor)

      fc=1.d0
      rewind(iatm)
      read(iatm,*)iu    ! iunit = 0: Ang. 1: Bohr
      if(iu.eq.0)fc=1.d0/au2ang

      do i=1,nat
        read(iatm,*)am,ia,iz,x,y,z
        if(iz.gt.0 .and. iz.le.maxza) call ElemZA(1,am,iz,am)
        if(iecp .gt. 0) read(icor,*)ia, ncore
        write(iwfn,100)am,i,i,x*fc,y*fc,z*fc,dble(iz-ncore)
      end do

100   format(2x,A3,i3,4x,'(CENTRE',i3,') ',3f12.8,'  CHARGE =',f5.1)

      return
      end

c-----------------------------------------------------------------------
c--- spherical MO --> Cartesian MO
c-----------------------------------------------------------------------
      subroutine sph2car(lq,fi,fo)
      implicit double precision (a-h,o-z)
c--- input & output MO factors
      dimension fi(9),fo(15)
c--- map relationship between pure and Cartesian basis functions
      common/carsph/dmap(6,5),fmap(10,7),gmap(15,9)
      parameter(
     *    c375 = 0.375d0,
     *    r3_4 = 0.8660254038d0,        ! sqrt(3/4)
     *    r5_4 = 1.1180339887d0,        ! sqrt(5/4)
     *    r6_5 = 1.0954451150d0,        ! sqrt(6/5)
     *    r9_7 = 1.1338934190d0,        ! sqrt(9/7)
     *   r10_7 = 1.1952286093d0,        ! sqrt(10/7)
     *    r5_8 = 0.7905694150d0,        ! sqrt(5/8)
     *    r9_8 = 1.0606601718d0,        ! sqrt(9/8)
     *   r5_16 = 0.5590169944d0,        ! sqrt(5/16)
     *  r27_28 = 0.9819805061d0,        ! sqrt(27/28)
     *  r35_64 = 0.7395099729d0,        ! sqrt(35/64)
     * r27_560 = 0.2195775164d0,        ! sqrt(27/560)
     *    v3_4 =-0.8660254038d0,        !-sqrt(3/4)
     *    v5_4 =-1.1180339887d0,        !-sqrt(5/4)
     *    v3_8 =-0.6123724357d0,        !-sqrt(3/8)
     *    v5_8 =-0.7905694150d0,        !-sqrt(5/8)
     *    v9_8 =-1.0606601718d0,        !-sqrt(9/8)
     *   v5_16 =-0.5590169944d0,        !-sqrt(5/16)
     *  v27_16 =-1.2990381057d0,        !-sqrt(27/16)
     *   v9_20 =-0.6708203932d0,        !-sqrt(9/20)
     *   v5_28 =-0.4225771274d0,        !-sqrt(5/28)
     *  v27_28 =-0.9819805061d0,        !-sqrt(27/28)
     *  v27_35 =-0.8783100657d0,        !-sqrt(27/35)
     *   v3_40 =-0.2738612788d0,        !-sqrt(3/40)
     *   v9_56 =-0.4008918629d0,        !-sqrt(9/56)
     *  v45_56 =-0.8964214570d0)        !-sqrt(45/56)

c--- In pure basis functions, MOLDEN ordering is used.
c--- In Cartesian basis functions, MOLDEN order is used and will be
c---   re-ordered in subroutine writecnt.
c--- Ref. subroutine purdf in espot.f of MOLDEN 4.8. The result agrees
c---   with that of MOLPRO.

      data ((dmap(j,i),j=1,6),i=1,5) /
c  6D:     xx      yy      zz      xy      xz      yz                            5D:
     * -0.5d0, -0.5d0,  1.0d0,  0.0d0,  0.0d0,  0.0d0,                         ! d0  = zz-(xx+yy)/2
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  1.0d0,  0.0d0,                         ! d+1 = xz
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  1.0d0,                         ! d-1 = yz
     *   r3_4,   v3_4,  0.0d0,  0.0d0,  0.0d0,  0.0d0,                         ! d+2 = r3_4*(xx-yy)
     *  0.0d0,  0.0d0,  0.0d0,  1.0d0,  0.0d0,  0.0d0/                         ! d-2 = xy

      data ((fmap(j,i),j=1,10),i=1,7) /
c 10F:    xxx     yyy     zzz     xyy     xxy     xxz     xzz     yzz
c         yyz     xyz                                                            7F
     *  0.0d0,  0.0d0,  1.0d0,  0.0d0,  0.0d0,  v9_20,  0.0d0,  0.0d0,
     *  v9_20,  0.0d0,                                                         ! f0  = zzz-(xxz+yyz)*sqrt(9/20)
     *   v3_8,  0.0d0,  0.0d0,  v3_40,  0.0d0,  0.0d0,   r6_5,  0.0d0,
     *  0.0d0,  0.0d0,                                                         ! f+1 = -xxx*sqrt(3/8)-xyy*sqrt(3/40)+xzz*sqrt(6/5)
     *  0.0d0,   v3_8,  0.0d0,  0.0d0,  v3_40,  0.0d0,  0.0d0,   r6_5,
     *  0.0d0,  0.0d0,                                                         ! f-1 = -yyy*sqrt(3/8)-xxy*sqrt(3/40)+yzz*sqrt(6/5)
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   r3_4,  0.0d0,  0.0d0,
     *   v3_4,  0.0d0,                                                         ! f+2 = (xxz-yyz)*sqrt(3/4)
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0,  1.0d0,                                                         ! f-2 = xyz
     *   r5_8,  0.0d0,  0.0d0,   v9_8,  0.0d0,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0,  0.0d0,                                                         ! f+3 = xxx*sqrt(5/8)-xyy*sqrt(9/8)
     *  0.0d0,   v5_8,  0.0d0,  0.0d0,   r9_8,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0,  0.0d0/                                                         ! f-3 = yyy*sqrt(5/8)-xxy*sqrt(9/8)

      data ((gmap(j,i),j=1,15),i=1,9) /
c 15G:   xxxx    yyyy    zzzz    xxxy    xxxz    yyyx    yyyz    zzzx
c        zzzy    xxyy    xxzz    yyzz    xxyz    yyxz    zzxy                    9G
     *   c375,   c375,  1.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0,r27_560, v27_35, v27_35,  0.0d0,  0.0d0,  0.0d0,                 ! g0  = (xxxx+yyyy)*c375+zzzz+xxyy*r27_560+(xxzz+yyzz)*v27_35
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0, v45_56,  0.0d0,  0.0d0,  r10_7,
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  v9_56,  0.0d0,                 ! g+1 = xzzz*r10_7+xxxz*v45_56+yyxz*v9_56
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0, v45_56,  0.0d0,
     *  r10_7,  0.0d0,  0.0d0,  0.0d0,  v9_56,  0.0d0,  0.0d0,                 ! g-1 = yzzz*r10_7+yyyz*v45_56+xxyz*v9_56
     *  v5_16,  r5_16,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0,  0.0d0, r27_28, v27_28,  0.0d0,  0.0d0,  0.0d0,                 ! g+2 = -(xxxx-yyyy)*r5_16+(xxzz-yyzz)*r27_28
     *  0.0d0,  0.0d0,  0.0d0,  v5_28,  0.0d0,  v5_28,  0.0d0,  0.0d0,
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   r9_7,                 ! g-2 = (xxxy+xyyy)*v5_28+zzxy*r9_7
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,   r5_8,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   v9_8,  0.0d0,                 ! g+3 = xxxz*r5_8+yyxz*v9_8
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,   v5_8,  0.0d0,
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,   r9_8,  0.0d0,  0.0d0,                 ! g-3 = yyyz*v5_8+xxyz*r9_8
     * r35_64, r35_64,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,
     *  0.0d0, v27_16,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,                 ! g+4 = (xxxx+yyyy)*r35_64+xxyy*v27_16
     *  0.0d0,  0.0d0,  0.0d0,   r5_4,  0.0d0,   v5_4,  0.0d0,  0.0d0,
     *  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0,  0.0d0/                 ! g-4 = (xxxy-xyyy)*r5_4

      fo=0.d0
      select case(lq)
        case(2)    ! D
          do j=1,5
            do i=1,6
              fo(i)=fo(i)+dmap(i,j)*fi(j)
            end do
          end do
        case(3)    ! F
          do j=1,7
            do i=1,10
              fo(i)=fo(i)+fmap(i,j)*fi(j)
            end do
          end do
        case(4)    ! G
          do j=1,9
            do i=1,15
              fo(i)=fo(i)+gmap(i,j)*fi(j)
            end do
          end do
        case default  ! S,P
          fo(1:9)=fi
          return
      end select

      return
      end

c-----------------------------------------------------------------------
c--- write MO.s (spherical basis functions) to a temporary file.
c-----------------------------------------------------------------------
      subroutine backupmols(imol,ispn,imo0,nmo,nmotot,sumocc,ifspin,
     & ifbeta,iprog,th,tmp,ierr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      character*100 tmp
      dimension npure(5),puremo(9),ncart(5),cartmo(15),scal(9)
      data npure/1,3,5,7,9/,ncart/1,3,6,10,15/

c--- obtain scale factor for orca 2.7 (may be suitable for other versions)
c        class                           factor
c   1    s                             * 1.0
c        p
c        d
c        f(0,+1,-1,+2,-2)
c        g(0,+1,-1,+2,-2)
c   2    f(+3,-3)                      * -1.0
c        g(+3,-3,+4,-4)
c--- For low point group symmetries, the default MO factors by ORCA can not
c--- pass AIMALL's examination if there are f, g functions.
      scal=1.d0
      if(iprog.eq.1)scal(6:9)=-1.d0

      rewind(imol)
      rewind(ispn)
      rewind(imo0)

      sumocc=0.d0
      ierr=0
      ifspin=1    ! 0/1: without / with spin
      ifbeta=0    ! 0/1: without / with beta spin
      nmotot=0    ! total number of orbitals
      nmo=0       ! number of occupied orbitals
      ene=0.d0
      occ=0.d0
      Isp=0       ! 0 (unknown), 1 (alpha or alpha+beta), 2 (beta)

200   read(imo0,"(100a)",end=500)tmp
      if(len_trim(tmp).eq.0) goto 200
      call charl2u(tmp)
      if(index(tmp,'ENE').ne.0)then
        ene=0.d0
        is=index(tmp,'=')
c       in MOLDEN by ACES2-F/TeraChem, there may be " Ene=   ********" or a huge value
        if(index(tmp(is+1:),'***') .eq. 0) then
          read(tmp(is+1:),*) ene
          ene = sign(min(abs(ene), 1.d6), ene)
        end if
      else if(index(tmp,'OCCUP').ne.0)then
        is=index(tmp,'=')
        read(tmp(is+1:),*) occ
        nmotot=nmotot+1
        if(abs(occ).gt.th) nmo=nmo+1
        sumocc=sumocc+occ
      else if(index(tmp,'SPIN').ne.0)then
        Isp = MOspin(tmp)
        ifspin=min(ifspin,Isp)
        ifbeta=max(ifbeta,Isp/2)
      else if(index(tmp,'SYM').ne.0)then
c       do nothing
      else
c       write occ, ene, and spin
        write(imol,"(A7,f20.8,/,A7,f20.8)")' OCCUP=',occ,' ENE=  ',ene
        if(abs(occ).gt.th) write(ispn,"(i2,2d20.7)")Isp,occ,ene
c       dump MO coefficients
        idxmo=0
        do i=1,nbs
          ltyp=ibstyp(i)
          nrd=npure(ltyp+1)
          nou=ncart(ltyp+1)
          do j=1,nrd
            if(i.eq.1 .and. j.eq.1)then
              read(tmp,*,err=300)it,puremo(j)
            else
              read(imo0,*,err=300)it,puremo(j)
            end if
            puremo(j)=puremo(j)*scal(j)
            cycle
c           find a star in the MO coefficients!
300         ierr=1
            goto 500
          end do
c         There is a bug in NBO6: d(-1) and d(+1) should be exchanged!
          if(iprog.eq.9 .and. ltyp.eq.2) call swap(puremo(2),puremo(3))
          call sph2car(ltyp,puremo,cartmo)
          do j=1,nou
            idxmo=idxmo+1
            write(imol,"(i5,1x,d18.10)")idxmo,cartmo(j)
          end do
        end do
        ene=0.d0
        occ=0.d0
        Isp=0
      end if
      goto 200

500   return
      end

c-----------------------------------------------------------------------
c--- write MO.s (Cartesian basis functions) to a temporary file.
c-----------------------------------------------------------------------
      subroutine backupmolc(imol,ispn,imo0,nmo,nmotot,sumocc,ifspin,
     & ifbeta,ngc,th,tmp,ierr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp

      rewind(imol)
      rewind(ispn)
      rewind(imo0)

      sumocc=0.d0
      ierr=0
      ifspin=1    ! 0/1: without / with spin
      ifbeta=0    ! 0/1: without / with beta spin
      nmotot=0    ! total number of orbitals
      nmo=0       ! number of occupied orbitals
      ene=0.d0
      occ=0.d0
      Isp=0       ! 0 (unknown), 1 (alpha or alpha+beta), 2 (beta)

200   read(imo0,"(100a)",end=500)tmp
      if(len_trim(tmp).eq.0) goto 200
      call charl2u(tmp)
      if(index(tmp,'ENE').ne.0)then
        ene=0.d0
        is=index(tmp,'=')
c       in MOLDEN by ACES2-F/TeraChem, there may be " Ene=   ********" or a huge value
        if(index(tmp(is+1:),'***') .eq. 0) then
          read(tmp(is+1:),*) ene
          ene = sign(min(abs(ene), 1.d6), ene)
        end if
      else if(index(tmp,'OCCUP').ne.0)then
        is=index(tmp,'=')
        read(tmp(is+1:),*) occ
        nmotot=nmotot+1
        if(abs(occ).gt.th) nmo=nmo+1
        sumocc=sumocc+occ
      else if(index(tmp,'SPIN').ne.0)then
        Isp = MOspin(tmp)
        ifspin=min(ifspin,Isp)
        ifbeta=max(ifbeta,Isp/2)
      else if(index(tmp,'SYM').ne.0)then
c       do nothing
      else
c       write occ, ene, and spin
        write(imol,"(A7,f20.8,/,A7,f20.8)")' OCCUP=',occ,' ENE=  ',ene
        if(abs(occ).gt.th) write(ispn,"(i2,2d20.7)")Isp,occ,ene
c       dump MO coefficients
        do i=1,ngc
          if(i.gt.1) read(imo0,"(a100)")tmp
c         find a star in the MO coefficients!
          if(index(tmp,'*').ne.0)then
            ierr=1
            goto 500
          end if
          write(imol,"(a)")trim(tmp)
        end do
        ene=0.d0
        occ=0.d0
        Isp=0
      end if
      goto 200

500   return
      end

c-----------------------------------------------------------------------
c--- backup MO, and fill in missing zero coefficients if ishrt=1
c-----------------------------------------------------------------------
      subroutine fill0s(imo0,ncarmo,ishrt,tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp

      imod=44
      rewind(imo0)
      rewind(imod)

100   read(imod,"(100a)",end=9999)tmp
      call charl2u(tmp)
      if(index(tmp,'[MO]').ne.0)then
        if(ishrt .eq. 0)then
          goto 200
        else
          nc = ncarmo
          goto 400
        end if
      end if
      goto 100

200   read(imod,"(100a)",end=9999)tmp
      if(len_trim(tmp).eq.0) goto 200
      if(index(tmp,'[').ne.0) goto 9999
      write(imo0,"(100a)")trim(tmp)
      goto 200

400   read(imod,"(100a)",end=9990)tmp
      if(len_trim(tmp).eq.0) goto 400
      if(index(tmp,'[').ne.0) goto 9990
      if(index(tmp,'=').ne.0)then
        if(nc .lt. ncarmo .and. nc .gt. 0)then
          do i=nc+1,ncarmo
            write(imo0,"(i5,f16.6)")i,0.d0
          end do
        end if
        nc = 0
        write(imo0,"(100a)")trim(tmp)
        goto 400
      end if

      nc = nc + 1
      read(tmp,*)idx
      if(nc .lt. idx)then
        do i=nc,idx-1
          write(imo0,"(i5,f16.6)")i,0.d0
        end do
        nc = idx
      end if
      write(imo0,"(100a)")trim(tmp)
      goto 400

9990  if(nc .lt. ncarmo .and. nc .gt. 0)then
        do i=nc+1,ncarmo
          write(imo0,"(i5,f16.6)")i,0.d0
        end do
      end if
9999  write(imo0,*)
      return
      end

c-----------------------------------------------------------------------
c--- get the number of contracted basis functions
c-----------------------------------------------------------------------
      subroutine readng(tmp,al,ng)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp
      character*2 al

      read(tmp,*)al,ng

      return
      end

c-----------------------------------------------------------------------
c--- Write basis functions. 'SP' basis functions are saved separately.
c-----------------------------------------------------------------------
      subroutine truncate(imod,itmp,igtoin,tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp
      character*2 al

c---  When there are huge lines to analyze, open/close is not stable.
c---  So I moved open and close on the top of truncate.
c
c      open(itmp,file='temp123456789.tmp',status='new')

      call readng(tmp,al,ng)
      rewind(itmp)

      ng1=ng
      do i=1,ng
        if(al.eq.'SP')then
          read(imod,*)exp,fc1,fc2
        else
          read(imod,*)exp,fc1
          fc2=1.d0
        end if
        if(abs(fc1*fc2).gt.1.d-8)then
          if(al.eq.'SP')then
            write(itmp,"(E20.10,2x,E20.10,2x,E20.10)")exp,fc1,fc2
          else
            write(itmp,"(E20.10,2x,E20.10)")exp,fc1
          end if
        else
          ng1=ng1-1
          cycle
        end if
      end do

      if(al.eq.'SP')then
        write(igtoin,*)"S ",ng1,"1.0"
      else
        write(igtoin,*)al,ng1,"1.0"
      end if

      rewind(itmp)
      do i=1,ng1
        read(itmp,*)exp,fc1
        write(igtoin,"(E20.10,2x,E20.10)")exp,fc1
      end do

c--- SP functions are saved separately
      if(al.eq.'SP')then
        write(igtoin,*)"P ",ng1,"1.0"
        rewind(itmp)
        do i=1,ng1
          read(itmp,*)exp,fc1,fc2
          write(igtoin,"(E20.10,2x,E20.10)")exp,fc2
        end do
      end if

c      close(itmp,status='delete')

      return
      end

c-----------------------------------------------------------------------
c--- back up GTOs
c-----------------------------------------------------------------------
      subroutine backupgto(imod,igto,itmp,igtoin,igtold,nat,iprog,ifgto,
     &  tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp
      character*2 al
      logical find

      ispace=0
      ifirst=0
      ifgto=1

      open(itmp,file='temp123456789.tmp')
      open(igtoin,file='igt123456789.tmp')
      open(igtold,file='old123456789.tmp')
c--- step 1: backup original GTO
      rewind(imod)
      rewind(igtoin)

100   read(imod,"(100a)",end=150)tmp
      call charl2u(tmp)
c     [GTO]: MOLDEN file; [BASIS]: GABEDIT file
      find = index(tmp,'[GTO]').ne.0 .or. index(tmp,'[BASIS]').ne.0
      if(find)then    ! the first several blank lines are skipped
        do while(ifirst.eq.0)
          read(imod,"(100a)",end=500)tmp
          ifirst=len_trim(tmp)
        end do
        goto 201
      end if
      goto 100

150   write(*,*)"### Wrong! [GTO] or [BASIS] can not be found!"
      ifgto=0
      close(igtoin,status='delete')
      return

200   read(imod,"(100a)",end=500)tmp
201   call charl2u(tmp)
      if(index(tmp,'[').ne.0) then
        if(ispace.eq.0)write(igtoin,"(' E 0')")    ! E = END
        goto 500
      else
        if(len_trim(tmp).gt.0)then
          if(index(tmp,'S').ne.0.or.index(tmp,'P').ne.0.or.
     *       index(tmp,'D').ne.0.or.index(tmp,'F').ne.0.or.
     *       index(tmp,'G').ne.0.or.index(tmp,'H').ne.0)then
            call truncate(imod,itmp,igtoin,tmp)
          else
            write(igtoin,"(a)")trim(tmp)
          end if
          ispace=0
        else
          if(ispace.eq.0)then
            write(igtoin,"(' E 0')")    ! E = END
            ispace=1                    ! the second blank line is skipped
          end if
        end if
      end if
      goto 200

500   continue

c--- step 2: re-normalize GTO and copy it to igtold because the GTO in the
c--- MOLDEN file may be unnormalized
      call bknorm(igtoin,igtold,iprog,ifgto)

c--- setp 3: reorder, and dump igtold to igto
      if(ifgto .eq. 1) call dumpbs(igto,igtold,nat,ifgto,tmp)

      close(igtoin,status='delete')
      close(igtold,status='delete')
      close(itmp,status='delete')

      return
      end

c-----------------------------------------------------------------------
c--- reorder, and dump igtold to igto
c    NOTE: because of some uncertainties in the MOLDEN format, atoms in
c    {Atoms} and [GTO] must be ordered ascendingly.
c-----------------------------------------------------------------------
      subroutine dumpbs(igto,igtold,nat,ierr,tmp)
      implicit double precision (a-h,o-z)
      character*100 tmp

      rewind(igto)

      do i=1,nat
        call locatm(igtold,i,ierr,tmp)
        if(ierr.eq.0)goto 9999
        write(igto,"(i5,' 0')")i
100     read(igtold,"(100a)",end=200)tmp
        if(tmp(1:1).eq.'&')goto 200
        write(igto,"(a)")trim(tmp)
        goto 100
200     continue
      end do

9999  return
      end

c-----------------------------------------------------------------------
c--- locate atom-i in igtold
c-----------------------------------------------------------------------
      subroutine locatm(igtold,i,ierr,tmp)
      implicit double precision (a-h,o-z)
      character*100 tmp

      ierr=0
      rewind(igtold)
100   read(igtold,"(100a)",end=1000)tmp
      if(tmp(1:1).ne.'&')goto 100
      read(tmp(2:100),*)it
      if(it.ne.i)goto 100
      ierr=1
      return

1000  write(*,"(/,' ### Wrong! No basis for atom ',i5,/)")i
      return
      end

c-----------------------------------------------------------------------
c--- renormalize the basis set. it is important for some basis sets (eg.
c---   helium 6-31G)
c-----------------------------------------------------------------------
      subroutine bknorm(igtoin,igtold,iprog,ierr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      character*1 al

      rewind(igtold)
      rewind(igtoin)

      iat=0
100   read(igtoin,*,end=500)ic1
      iat=iat+1
c     check compatibility: because of some uncertainties in the MOLDEN
c     format, the atomic indices must be 1,2,3,4,...
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     It's found that in Molden 5.0, if the ordering of GTO centers is,
c     for example, 3,1,2, then the MO coefficients in [MO] are also in
c     the same order 3,1,2.
c     This means that the atoms in [Atoms] should be reordered according
c     to the ordering in [GTO]. Example:
c
c     < original MOLDEN file >
c
c     [Atoms] Angs
c     F     1    9    ...
c     H     2    1    ...
c     [GTO]
c       2 0
c     ... (basis functions of H)
c       1 0
c     ... (basis functions of F)
c
c     < modified MOLDEN file >
c
c     [Atoms] Angs
c     H     1    1    ...
c     F     2    9    ...
c     [GTO]
c       1 0
c     ... (basis functions of H)
c       2 0
c     ... (basis functions of F)
c
c     However in CFour's MOLDEN, the atomic numbers in [GTO] should be
c     corrected.
cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if(iat .ne. ic1)then
        write(*,"(
     &    ' Error: the atoms in [GTO] are not ordered ascendingly.',/,
     &    ' Please correct the MOLDEN file using ReOrdAtm in util by')")
        if(iprog .eq. 2)then
          write(*,"(/,' roa.exe -m 1 < old_molden > new_molden')")
        else
          write(*,"(/,' roa.exe < old_molden > new_molden')")
        end if
        ierr=0
        goto 500
      end if

      write(igtold,"('&',i5,' 0')")ic1
200   read(igtoin,*)al,np
c--- maxpgc is much larger than np
c      if(np.gt.maxpgc)then
c        write(*,*)"Error: too many contracted Gaussian functions!"
c        write(*,*)" NP=",np," MAXPGC=",maxpgc
c        write(*,*)"Please increase MAXPGC and try again."
c        call estop
c      end if
      if(al.eq.'E'.and.np.eq.0)then
        write(igtold,"(1x,a1,1x,i1)")al,np
        goto 100
      else
        write(igtold,"(1x,a1,i4,' 1.0')")al,np
      end if

      do i=1,np
        read(igtoin,*)expgc(i),confc(i)
        cbs=1.d0
c       Orca, PSI4, NBO6: transform the basis set into input format
        if(iprog .eq. 1 .or. iprog .eq. 7 .or. iprog .eq. 9)
     &    cbs=fnorm(expgc(i),al)
        confc(i)=confc(i)/cbs
      end do

c--- For uncontracted basis functions, the contraction coefficient can be
c    renormalized to +1.0 or -1.0, depending on its sign. Do not change the sign!
      call renorm(al,expgc,confc,np)
      do i=1,np
        write(igtold,"(d20.10,2x,d20.10)")expgc(i),confc(i)
      end do
      goto 200

500   continue

      return
      end

c-----------------------------------------------------------------------
c--- calculate the normalization factor for GTO(L)
c-----------------------------------------------------------------------
      function fnorm(ex,al)
      implicit double precision (a-h,o-z)
      character*1 al

      pi=acos(-1.d0)
      pi3=pi**3.d0

c---  unnormalize primitives
c---  Normal^4 = 2^n1 * a^n2 / (pi^3 * nf)
c---  where n1=3+4*L; n2=3+2*L, nf=[(2L-1)!!]^2
      call power(al,n1,n2,nf)
      f = (2.d0**dble(n1)) * (ex**dble(n2)) / (pi3 * dble(nf))
      fnorm=sqrt(sqrt(f))

      return
      end

c-----------------------------------------------------------------------
c--- back up atoms and coordinates
c-----------------------------------------------------------------------
      subroutine backupatm(imod,iatm,ifatm,tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp
      character*3 element

      ifatm=1

      rewind(imod)
      rewind(iatm)

100   read(imod,"(100a)",end=1010)tmp
      call charl2u(tmp)
      if(index(tmp,'[ATOMS]').ne.0) then
        if(index(tmp,'ANGS').ne.0)then
          iunit=0
        else if(index(tmp,'AU').ne.0)then
          iunit=1
        else
          iunit=2
        end if
        goto 200
      end if
      goto 100

200   write(iatm,"(i1)")iunit
201   read(imod,"(100a)",end=500)tmp
      call charl2u(tmp)
      if(index(tmp,'[').ne.0) then
        goto 500
      else
cooo        write(iatm,"(a)")trim(tmp)

c       core electrons by ECP may be not inclued in iz (eg. in Molpro 2015), so iz should be obtained from atomic name
c       read: atomic_name number atomic_number x y z
        read(tmp,*,err=1020,end=1020)element,ia,iz0,x,y,z
c       eliminate non-letter characters for a special case, for example, O_1 (Dalton), C1 (Cadpac)
        call rmnumb(3,element)
        call ElemZA(0,element,za,za)
c       In the Molden program, atomic_name can be any characters and is omitted,
c       so iz can be 0. In this case read iz from iz0.
        iz = nint(za)
        if(iz .eq. 0) iz = iz0

        write(iatm,"(a3,1x,2i6,3f24.12)")element,ia,iz,x,y,z
      end if
      goto 201

500   return

1010  write(*,*)"*** Wrong! [ATOMS] can not be found!"
      ifatm=0
      return
1020  write(*,*)"*** Error when reading the [ATOMS] section!"
      ifatm=0
      return

      end

c-----------------------------------------------------------------------
c---  replace non-letter characters by space
c-----------------------------------------------------------------------
      subroutine rmnumb(N,cha)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*(*) cha

      do i=1,N
        if((ichar(cha(i:i)).ge.65) .and. (ichar(cha(i:i)).le.90)) cycle     ! A-Z
        if((ichar(cha(i:i)).ge.97) .and. (ichar(cha(i:i)).le.122)) cycle    ! a-z
        cha(i:i)=' '
      end do

      return
      end

c-----------------------------------------------------------------------
c---  Routine to clear N characters
c-----------------------------------------------------------------------
      Subroutine CClear(N,CA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      Character*(*) CA

      Do I = 1,N
        CA(I:I) = " "
      end do

      Return
      End

c-----------------------------------------------------------------------
c--- count the numbers of Cartesian and Spherical basis functions from
c--- GTO.
c-----------------------------------------------------------------------
      subroutine npgau(igto,Ierr,ncar,nsph,MaxL,tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
c--- Cartesian NC-/C-GTO; Spherical NC-/C-GTO
      dimension ncar(2),nsph(2)
      character*100 tmp
      character*2 al

      ns=0
      np=0
      nd=0
      nf=0
      ng=0
      nsc=0
      npc=0
      ndc=0
      nfc=0
      ngc=0
      ibs=0
      MaxL=0
      Ierr=0

      rewind(igto)
200   read(igto,"(100a)",end=500)tmp

      if(index(tmp,'S ').ne.0)then
        call readng(tmp,al,npg)
        ns=ns+npg
        nsc=nsc+1
        ibs=ibs+1
        if(ibs.le.maxpgc)ibstyp(ibs)=0
      else if(index(tmp,'P ').ne.0)then
        call readng(tmp,al,npg)
        np=np+npg
        npc=npc+1
        ibs=ibs+1
        if(ibs.le.maxpgc)ibstyp(ibs)=1
      else if(index(tmp,'D ').ne.0)then
        call readng(tmp,al,npg)
        nd=nd+npg
        ndc=ndc+1
        ibs=ibs+1
        if(ibs.le.maxpgc)ibstyp(ibs)=2
      else if(index(tmp,'F ').ne.0)then
        call readng(tmp,al,npg)
        nf=nf+npg
        nfc=nfc+1
        ibs=ibs+1
        if(ibs.le.maxpgc)ibstyp(ibs)=3
      else if(index(tmp,'G ').ne.0)then
        call readng(tmp,al,npg)
        ng=ng+npg
        ngc=ngc+1
        ibs=ibs+1
        if(ibs.le.maxpgc)ibstyp(ibs)=4
      else if(index(tmp,'H ').ne.0)then
        Ierr=1
        goto 600
      end if

      goto 200

500   ncar(1)=ns+np*3+nd*6+nf*10+ng*15
      ncar(2)=nsc+npc*3+ndc*6+nfc*10+ngc*15
      nsph(1)=ns+np*3+nd*5+nf*7+ng*9
      nsph(2)=nsc+npc*3+ndc*5+nfc*7+ngc*9
      nbs=ibs
c      write(*,*)ncar,nsph,nbs

c--- ncar(1)>=nsph(1)
c--- ncar(2)>=nsph(2)>=nbs
c--- so it's enough to check NCar only
      if(ncar(1).gt.maxpg)then
        write(*,"(//,1x,77('-'))")
        write(*,"(' Error: too many primitive Gaussian functions!')")
        write(*,"('  NCar(1) = ',i7,'   MaxPG = ',i7)")ncar(1),maxpg
        write(*,"(' Please increase MaxPG and try again.',/,
     *            1x,77('-'))")
        Ierr=2
      end if
      if(ncar(2).gt.maxpgc)then
        write(*,"(//,1x,77('-'))")
        write(*,"(' Error: too many contracted Gaussian functions!')")
        write(*,"('  NCar(2) = ',i7,'   MaxPGC = ',i7)")ncar(2),maxpgc
        write(*,"(' Please increase MaxPGC and try again.',/,
     *            1x,77('-'))")
        Ierr=2
      end if

c     MaxL
      if(ng.gt.0)then
        MaxL=4
      else if(nf.gt.0)then
        MaxL=3
      else if(nd.gt.0)then
        MaxL=2
      else if(np.gt.0)then
        MaxL=1
      else
        MaxL=0
      end if

600   continue

      return
      end

c-----------------------------------------------------------------------
c--- count the number of atoms.
c-----------------------------------------------------------------------
      subroutine natom(iatm,nat,nchar,iunit,ierr)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*10 tmp

      ierr=0

      iat=0
      nchar=0
      rewind(iatm)
      read(iatm,*)iunit

200   read(iatm,*,end=500,err=300)tmp,nat,icha
      iat=iat+1
c     check compatibility: because of some uncertainties in the MOLDEN
c     format, the atomic indices must be 1,2,3,4,...
      if(iat .ne. nat)then
        write(*,"(
     &    ' Error: atoms in [Atoms] are not ordered ascendingly.',/,
     &    ' Please correct the MOLDEN file using ReOrdAtm in util.')")
        ierr=1
        goto 500
      end if
      nchar=nchar+icha
      goto 200

c--- In the geometry optimization of deMon2k, the format is
c--- "atom, x, y, z"
300   write(*,*)"*** The [Atoms] section is wrong!"
      write(*,*)"Please check your MOLDEN file carefully."
      ierr=1

500   continue

      return
      end

c-----------------------------------------------------------------------
c--- tmp --> TMP
c-----------------------------------------------------------------------
      subroutine charl2u(tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*(*) tmp
      character*1 L2U

      do i=1,len_trim(tmp)
        tmp(i:i)=L2U(tmp(i:i))
      end do

      return
      end

c-----------------------------------------------------------------------
c---  CHA --> cha
c-----------------------------------------------------------------------
      subroutine charu2l(cha)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*(*) cha
      character*1 U2L

      do i=1,len_trim(cha)
        cha(i:i)=U2L(cha(i:i))
      end do

      return
      end

c-----------------------------------------------------------------------
c---  l --> L
c-----------------------------------------------------------------------
      function L2U(letter)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*1 letter,L2U
      if((ichar(letter).ge.97).and.(ichar(letter).le.122))then
        L2U=char(ichar(letter)-32)
      else
        L2U=letter
      endif
      return
      end

c-----------------------------------------------------------------------
c---  L --> l
c-----------------------------------------------------------------------
      function U2L(letter)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*1 letter,U2L
      if((ichar(letter).ge.65).and.(ichar(letter).le.90))then
        U2L=char(ichar(letter)+32)
      else
        U2L=letter
      endif
      return
      end

c-----------------------------------------------------------------------
c--- length of a string without the first and last spaces.
c-----------------------------------------------------------------------
      function nonspace(string)
      implicit double precision (a-h,o-z)
      character*(*) string
      character*1 space

      space=' '
      length=LEN_TRIM(string)
      if(length.eq.0) then
       i=1
      else
       do i=1,length
         if(string(i:i).ne.space) goto 20
       end do
      endif

20    nonspace=i

      return
      end

c-----------------------------------------------------------------------
c--- lenchar: length of a string without tail spaces.
c-----------------------------------------------------------------------
      function lenchar(string)
      implicit double precision (a-h,o-z)
      character*(*) string
      character*1 space

      space=' '
      i=len(string)

      do 10 while(i.gt.0.and.string(i:i).eq.space)
        i=i-1
10    continue

      lenchar=i

      return
      end

c-----------------------------------------------------------------------
c--- trulen: true length of a string
c--- len1: pointor to the first non-space character
c--- len2: pointor to the last non-space character
c--- length: true length of a string without the initial and tail spaces
c-----------------------------------------------------------------------
      subroutine trulen(cha,len1,len2,length)
      implicit double precision (a-h,o-z)
      character*(*) cha

      len1=nonspace(cha)
      len2=lenchar(cha)
      length=len2-len1+1

      return
      end

c-----------------------------------------------------------------------
c--- renormalize a contracted basis function
c-----------------------------------------------------------------------
      subroutine renorm(al,a,ci,ngauss)
      implicit double precision (a-h,o-z)
      parameter (tol=1.0d-10,maxpgc=10000)
      dimension a(*),ci(*),c(maxpgc)
      character*1 al

      pi=acos(-1.d0)
      pi3=pi**3.d0

c--- ngauss.le.maxpgc has been checked in subroutine bknorm

c--- unnormalize primitives
c--- Normal^4 = 2^n1 * a^n2 / (pi^3 * nf)
c---   n1=3+4*L; n2=3+2*L, nf=[(2L-1)!!]^2
      call power(al,n1,n2,nf)
      fc = (2.d0**dble(n1)) / (pi3 * dble(nf))
      do i = 1,ngauss
        f = fc * (a(i)**dble(n2))
        f = sqrt(sqrt(f))
        c(i) = ci(i)*f
      end do

      fsum = 0.d0
      do i = 1,ngauss
        do j = 1,i
          a2 = (a(i)+a(j))/2.d0
          f = fc * (a2**dble(n2))
          f = sqrt(f)
          f = c(i)*c(j)/f
          if (i .ne. j) f = f*2.d0
          fsum = fsum+f
        end do
      end do

      if (fsum .gt. tol) fsum = 1.d0/sqrt(fsum)
      do i = 1,ngauss
        ci(i) = ci(i) * fsum
      end do

      return
      end

c-----------------------------------------------------------------------
c--- get power(n1,n2,nf) for GTO(L) normalization
c--- n1=3+4*L; n2=3+2*L, nf=[(2L-1)!!]^2
c-----------------------------------------------------------------------
      subroutine power(al,n1,n2,nf)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*1 al

      n1=0
      n2=0
      nf=0
      select case(al)
        case('S')
          n1=3
          n2=3
          nf=1
        case('P')
          n1=7
          n2=5
          nf=1
        case('D')
          n1=11
          n2=7
          nf=9
        case('F')
          n1=15
          n2=9
          nf=225
        case('G')
          n1=19
          n2=11
          nf=11025
      end select

      return
      end

c-----------------------------------------------------------------------
c---  compute scaling factors for MO coefficients
c-----------------------------------------------------------------------
      subroutine moscale(igto,iprog,ncg)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(maxpg=14000,maxpgc=10000)
      common/gtf/expg(maxpg),conf(maxpg),expgc(maxpgc),confc(maxpgc),
     *cfmo(maxpg),cn(maxpg),scalmo(maxpgc),
     *nbs,icnt(maxpg),ityp(maxpg),icmo(maxpg),ibstyp(maxpgc)
      dimension itypc(maxpgc)
      character*1 al

c     cfour, aces2, or molcas (cart.)
      if(iprog.eq.2 .or. iprog.eq.5 .or. iprog.eq.6)then
        goto 100
c     turbomole
      else if(iprog.eq.3)then
        goto 200
c     mrcc (cart.)
      else if(iprog.eq.8)then
        goto 300
      else
        goto 5000
      end if

100   rewind(igto)
      ip1=0
      ip2=0
c---  Cartesian CGTO types of cfour, aces2, or molcas (cart.)
110   read(igto,*,end=5000)
120   read(igto,*)al,np
      if(al.eq.'E'.and.np.eq.0)goto 110
      do i=1,np
        read(igto,*)
      end do
      select case(al)
        case('S')
          ip1=ip2+1
          ip2=ip2+1
          itypc(ip1:ip2)=1
        case('P')
          ip1=ip2+1
          ip2=ip2+3
          itypc(ip1:ip2)=1
        case('D')
          ip1=ip2+1
          ip2=ip2+6
          itypc(ip1:(ip1+2))=2
          itypc((ip1+3):ip2)=1
        case('F')
          ip1=ip2+1
          ip2=ip2+10
          itypc(ip1:(ip1+2))=4
          itypc((ip1+3):(ip2-1))=2
          itypc(ip2:ip2)=1
        case('G')
          ip1=ip2+1
          ip2=ip2+15
          itypc(ip1:(ip1+2))=5
          itypc((ip1+3):(ip1+8))=4
          itypc((ip1+9):(ip1+11))=3
          itypc((ip2-2):ip2)=2
      end select
      goto 120

200   rewind(igto)
      ip1=0
      ip2=0
c---  Cartesian CGTO types of turbomole
210   read(igto,*,end=5000)
220   read(igto,*)al,np
      if(al.eq.'E'.and.np.eq.0)goto 210
      do i=1,np
        read(igto,*)
      end do
      select case(al)
        case('S')
          ip1=ip2+1
          ip2=ip2+1
          itypc(ip1:ip2)=1
        case('P')
          ip1=ip2+1
          ip2=ip2+3
          itypc(ip1:ip2)=1
        case('D')
          ip1=ip2+1
          ip2=ip2+6
          itypc(ip1:ip2)=2
        case('F')
          ip1=ip2+1
          ip2=ip2+10
          itypc(ip1:ip2)=3
        case('G')
          ip1=ip2+1
          ip2=ip2+15
          itypc(ip1:ip2)=4
      end select
      goto 220

300   rewind(igto)
      ip1=0
      ip2=0
c---  Cartesian CGTO types of mrcc
310   read(igto,*,end=5000)
320   read(igto,*)al,np
      if(al.eq.'E'.and.np.eq.0)goto 310
      do i=1,np
        read(igto,*)
      end do
      select case(al)
        case('S')
          ip1=ip2+1
          ip2=ip2+1
          itypc(ip1:ip2)=1
        case('P')
          ip1=ip2+1
          ip2=ip2+3
          itypc(ip1:ip2)=1
        case('D')
          ip1=ip2+1
          ip2=ip2+6
          itypc(ip1:(ip1+2))=1
          itypc((ip1+3):ip2)=2
        case('F')
          ip1=ip2+1
          ip2=ip2+10
          itypc(ip1:(ip1+2))=1
          itypc((ip1+3):(ip2-1))=3
          itypc(ip2:ip2)=4
        case('G')
          ip1=ip2+1
          ip2=ip2+15
          itypc(ip1:(ip1+2))=1
          itypc((ip1+3):(ip1+8))=5
          itypc((ip1+9):(ip1+11))=6
          itypc((ip2-2):ip2)=7
      end select
      goto 320

5000  continue
c      write(99,*)ip2
c      write(99,"(i4)")itypc(1:ip2)

      if(iprog.eq.2 .or. iprog.eq.5 .or. iprog.eq.6)then
c---    cfour, aces2 (Cart.), or molcas (Cart.)
        do i=1,ncg
          scalmo(i)=obscalc4(itypc(i))
        end do
      else if(iprog.eq.3)then
c---    turbomole (Cart.)
        do i=1,ncg
          scalmo(i)=obscaltm(itypc(i))
        end do
      else if(iprog.eq.8)then
c---    mrcc (Cart.)
        do i=1,ncg
          scalmo(i)=obscalmr(itypc(i))
        end do
      else
c---    default; orca (spher.); jaguar
        do i=1,ncg
          scalmo(i)=1.d0
        end do
      end if

      return
      end

c-----------------------------------------------------------------------
c---  obtain scale factor for mrcc (Cart.)
c     class                                factor
c     1    s                             * 1.0
c          p(x,y,z)                      * 1.0
c          d(xx,yy,zz)
c          f(xxx,yyy,zzz)
c          g(x4,y4,z4)
c     2    d(xy,xz,yz)                   * 1/sqrt(3)
c     3    f(xyy,xzz,yxx,yzz,zxx,zyy)    * 1/sqrt(5)
c     4    f(xyz)                        * 1/sqrt(15)
c     5    g(x3y,x3z,y3x,y3z,z3x,z3y)    * 1/sqrt(7)
c     6    g(x2y2,x2z2,y2z2)             * sqrt(3/35)
c     7    g(x2yz,y2xz,z2xy)             * 1/sqrt(35)
c-----------------------------------------------------------------------
      function obscalmr(iclass)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      select case(iclass)
        case(1)
          a=1.d0
        case(2)
          a=sqrt(1.d0/3.d0)
        case(3)
          a=sqrt(1.d0/5.d0)
        case(4)
          a=sqrt(1.d0/15.d0)
        case(5)
          a=sqrt(1.d0/7.d0)
        case(6)
          a=sqrt(3.d0/35.d0)
        case(7)
          a=sqrt(1.d0/35.d0)
      end select

      obscalmr=a

      return
      end

c-----------------------------------------------------------------------
c---  obtain scale factor for turbomole
c     class                                factor
c     1    s                             * 1.0
c          p
c     2    d                             * sqrt(3)
c     3    f                             * sqrt(15)
c     4    g                             * sqrt(105)
c-----------------------------------------------------------------------
      function obscaltm(iclass)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      select case(iclass)
        case(1)
          a=1.d0
        case(2)
          a=sqrt(3.d0)
        case(3)
          a=sqrt(15.d0)
        case(4)
          a=sqrt(105.d0)
      end select

      obscaltm=a

      return
      end

c-----------------------------------------------------------------------
c---  obtain scale factor for cfour
c     class                                factor
c     1    s                             * 1.0
c          p(x,y,z)
c          d(xy,xz,yz)
c          f(xyz)
c     2    d(xx,yy,zz)                   * sqrt(3)
c          f(xyy,xzz,yxx,yzz,zxx,zyy)
c          g(x2yz,y2xz,z2xy)
c     3    g(x2y2,x2z2,y2z2)             * 3.0
c     4    f(xxx,yyy,zzz)                * sqrt(15)
c          g(x3y,x3z,y3x,y3z,z3x,z3y)
c     5    g(x4,y4,z4)                   * sqrt(105)
c-----------------------------------------------------------------------
      function obscalc4(iclass)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)

      select case(iclass)
        case(1)
          a=1.d0
        case(2)
          a=sqrt(3.d0)
        case(3)
          a=3.d0
        case(4)
          a=sqrt(15.d0)
        case(5)
          a=sqrt(105.d0)
      end select

      obscalc4=a

      return
      end

c-----------------------------------------------------------------------
c---  calculate the overlap matrix element
c---  s = <itype1, a1, r1 | itype2, a2, r2>
c---    = <l1, m1, n1, a1, r1 | l2, m2, n2, a2, r2>
c-----------------------------------------------------------------------
      subroutine overlap(s,itype1,a1,r1,itype2,a2,r2,MaxL,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension r1(3),r2(3),p(3),dgn(0:MaxL),pan(0:MaxL,3),pbn(0:MaxL,3)
      data one/1.d0/
      save one

      pi=acos(-one)

c--- production of the normalization factors
      s=fnorm_lmn(a1,itype1)*fnorm_lmn(a2,itype2)

c---  gamma = as + bs and (2*gamma)^-n
      g=a1+a2
      dg=g+g
      dgn(0)=one
      do i=1,MaxL
        dgn(i)=dgn(i-1)/dg
      end do

      tmp1=dist(r1,r2)
      s=s*exp(-a1*a2*tmp1*tmp1/g)
      tmp1=sqrt(pi/g)
      s=s*tmp1*tmp1*tmp1

c---  P point
      p(1)=(a1*r1(1)+a2*r2(1))/g
      p(2)=(a1*r1(2)+a2*r2(2))/g
      p(3)=(a1*r1(3)+a2*r2(3))/g

c     pa^n and pb^n
      do j=1,3
        pan(0,j)=one
        pbn(0,j)=one
      end do
      if(MaxL .gt. 0)then
        do j=1,3
          pan(1,j)=p(j)-r1(j)
          pbn(1,j)=p(j)-r2(j)
        end do
        do i=2,MaxL
          do j=1,3
            pan(i,j)=pan(i-1,j)*pan(1,j)
            pbn(i,j)=pbn(i-1,j)*pbn(1,j)
          end do
        end do
      end if

      call pattwf(itype1,l1,m1,n1,info)
        if(info.ne.0) goto 9000
      call pattwf(itype2,l2,m2,n2,info)
        if(info.ne.0) goto 9000

      call integ(sx,MaxL,l1,l2,dgn,pan(0,1),pbn(0,1))
      call integ(sy,MaxL,m1,m2,dgn,pan(0,2),pbn(0,2))
      call integ(sz,MaxL,n1,n2,dgn,pan(0,3),pbn(0,3))
      s=s*sx*sy*sz

9000  return
      end

c-----------------------------------------------------------------------
c---  calculate the integral Ix, Iy, or Iz
c---    (l1+l2)/2
c---  I = sum [fcoef * (2i-1)!! / (2g)^i]
c---      i=0
c-----------------------------------------------------------------------
      subroutine integ(s,MaxL,l1,l2,dgn,pan,pbn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
c     Tlm1ff = (2N -1)!!, N=0~5; (2g)^-i; pa^n; pb^n
      dimension Tlm1ff(0:5),dgn(0:MaxL),pan(0:MaxL),pbn(0:MaxL)
      data Tlm1ff/1.D0, 1.D0, 3.D0, 15.D0, 105.D0, 945.D0/
      save Tlm1ff

      s=0.d0
      do i=0,(l1+l2)/2
        call fcoef(tmp,MaxL,i+i,l1,l2,pan,pbn)
        tmp=tmp*Tlm1ff(i)*dgn(i)
        s=s+tmp
      end do

      return
      end

c-----------------------------------------------------------------------
c--- calculate the coefficients
c---           l1   l2
c--- fcoef =  sum  sum [clm(l1,k1) * clm(l2,k2) * a^(l1-k1) * b^(l2-k2)]
c---         k1=0 k2=0
c---          k1+k2=i
c-----------------------------------------------------------------------
      subroutine fcoef(fc,MaxL,i,l1,l2,pan,pbn)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension pan(0:MaxL),pbn(0:MaxL)

      fc=0.d0
      do k1=0,l1
        k2=i-k1
        if(k2.lt.0 .or. k2.gt.l2) cycle
        fc = fc + pan(l1-k1) * pbn(l2-k2) * clm(l1,k1) * clm(l2,k2)
      end do

      return
      end

c-----------------------------------------------------------------------
c---  clm = l! / (m! * (l-m)!)
c-----------------------------------------------------------------------
      function clm(l,m)
      implicit real*8(a-h,o-z)
      dimension factorial(0:5)
      data factorial/1.D0,1.D0,2.D0,6.D0,24.D0,120.D0/
      save factorial

      clm=factorial(l)/(factorial(m)*factorial(l-m))

      return
      end

c-----------------------------------------------------------------------
c--- distance between two points
c-----------------------------------------------------------------------
      function dist(p1,p2)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension p1(3),p2(3)

      dist=0.d0
      do i=1,3
        dist=dist+(p1(i)-p2(i))*(p1(i)-p2(i))
      end do
      dist=sqrt(dist)

      return
      end

c-----------------------------------------------------------------------
c--- vout = c * vin
c-----------------------------------------------------------------------
      subroutine ascale(N,c,vin,vout)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension vin(*),vout(*)

      do i=1,N
        vout(i)=c*vin(i)
      end do

      return
      end

c-----------------------------------------------------------------------
c---  Routine to clear N elements in array A.
c-----------------------------------------------------------------------
      Subroutine AClear(N,A)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(Zero=0.0d0)
      Dimension A(*)

      Do I = 1,N
        A(I) = Zero
      end do

      Return
      End

c-----------------------------------------------------------------------
c--- Obtain the xyz pattern for a given Cartesian type number. It is
c--- used in MOLDEN.
c--- Note: the ordering 14-19 of F functions is different from the one
c--- in subroutine pattwf.
c--- 1  S     | 11 FXXX  | 21 GXXXX | 31 GXXZZ |
c--- 2  PX    | 12 FYYY  | 22 GYYYY | 32 GYYZZ |
c--- 3  PY    | 13 FZZZ  | 23 GZZZZ | 33 GXXYZ |
c--- 4  PZ    | 14 FXYY  | 24 GXXXY | 34 GXYYZ |
c--- 5  DXX   | 15 FXXY  | 25 GXXXZ | 35 GXYZZ |
c--- 6  DYY   | 16 FXXZ  | 26 GXYYY |
c--- 7  DZZ   | 17 FXZZ  | 27 GYYYZ |
c--- 8  DXY   | 18 FYZZ  | 28 GXZZZ |
c--- 9  DXZ   | 19 FYYZ  | 29 GYZZZ |
c--- 10 DYZ   | 20 FXYZ  | 30 GXXYY |
c---
c--- Ordering of G functions in Gaussian. For debug only.
c--- 21 GZZZZ | 31 GXXYZ |
c--- 22 GYZZZ | 32 GXXYY |
c--- 23 GYYZZ | 33 GXXXZ |
c--- 24 GYYYZ | 34 GXXXY |
c--- 25 GYYYY | 35 GXXXX |
c--- 26 GXZZZ |
c--- 27 GXYZZ |
c--- 28 GXYYZ |
c--- 29 GXYYY |
c--- 30 GXXZZ |
c-----------------------------------------------------------------------
      subroutine pattml(itype,l,m,n,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension PATDAT(3,35)
      data PATDAT/
c              1          2          3          4          5
     &   0, 0, 0,   1, 0, 0,   0, 1, 0,   0, 0, 1,   2, 0, 0,
c              6          7          8          9         10
     &   0, 2, 0,   0, 0, 2,   1, 1, 0,   1, 0, 1,   0, 1, 1,
c             11         12         13         14         15
     &   3, 0, 0,   0, 3, 0,   0, 0, 3,   1, 2, 0,   2, 1, 0,
c             16         17         18         19         20
     &   2, 0, 1,   1, 0, 2,   0, 1, 2,   0, 2, 1,   1, 1, 1,
c             21         22         23         24         25
     &   4, 0, 0,   0, 4, 0,   0, 0, 4,   3, 1, 0,   3, 0, 1,
c             26         27         28         29         30
     &   1, 3, 0,   0, 3, 1,   1, 0, 3,   0, 1, 3,   2, 2, 0,
c             31         32         33         34         35
     &   2, 0, 2,   0, 2, 2,   2, 1, 1,   1, 2, 1,   1, 1, 2/
cc<<< Gaussian (see also function fnorm_lmn)
cc             21         22         23         24         25
c     &   0, 0, 4,   0, 1, 3,   0, 2, 2,   0, 3, 1,   0, 4, 0,
cc             26         27         28         29         30
c     &   1, 0, 3,   1, 1, 2,   1, 2, 1,   1, 3, 0,   2, 0, 2,
cc             31         32         33         34         35
c     &   2, 1, 1,   2, 2, 0,   3, 0, 1,   3, 1, 0,   4, 0, 0/
cc>>>
      save PATDAT

      info = 0
      if(itype .lt. 1 .or. itype .gt. 35)then
        info = 1
        write(*,"(/,' ### Wrong!',
     *  ' The Cartesian type number is out of range:',i3)")itype
        return
      end if

      l=PATDAT(1,itype)
      m=PATDAT(2,itype)
      n=PATDAT(3,itype)

      return
      end

c-----------------------------------------------------------------------
c--- Obtain the xyz pattern for a given Cartesian type number. It is
c--- used in WFN and WFX.
c--- 1  S     | 11 FXXX  | 21 GXXXX | 31 GXXZZ |
c--- 2  PX    | 12 FYYY  | 22 GYYYY | 32 GYYZZ |
c--- 3  PY    | 13 FZZZ  | 23 GZZZZ | 33 GXXYZ |
c--- 4  PZ    | 14 FXXY  | 24 GXXXY | 34 GXYYZ |
c--- 5  DXX   | 15 FXXZ  | 25 GXXXZ | 35 GXYZZ |
c--- 6  DYY   | 16 FYYZ  | 26 GXYYY |
c--- 7  DZZ   | 17 FXYY  | 27 GYYYZ |
c--- 8  DXY   | 18 FXZZ  | 28 GXZZZ |
c--- 9  DXZ   | 19 FYZZ  | 29 GYZZZ |
c--- 10 DYZ   | 20 FXYZ  | 30 GXXYY |
c-----------------------------------------------------------------------
      subroutine pattwf(itype,l,m,n,info)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      dimension PATDAT(3,35)
      data PATDAT/
c              1          2          3          4          5
     &   0, 0, 0,   1, 0, 0,   0, 1, 0,   0, 0, 1,   2, 0, 0,
c              6          7          8          9         10
     &   0, 2, 0,   0, 0, 2,   1, 1, 0,   1, 0, 1,   0, 1, 1,
c             11         12         13         14         15
     &   3, 0, 0,   0, 3, 0,   0, 0, 3,   2, 1, 0,   2, 0, 1,
c             16         17         18         19         20
     &   0, 2, 1,   1, 2, 0,   1, 0, 2,   0, 1, 2,   1, 1, 1,
c             21         22         23         24         25
     &   4, 0, 0,   0, 4, 0,   0, 0, 4,   3, 1, 0,   3, 0, 1,
c             26         27         28         29         30
     &   1, 3, 0,   0, 3, 1,   1, 0, 3,   0, 1, 3,   2, 2, 0,
c             31         32         33         34         35
     &   2, 0, 2,   0, 2, 2,   2, 1, 1,   1, 2, 1,   1, 1, 2/
      save PATDAT

      info = 0
      if(itype .lt. 1 .or. itype .gt. 35)then
        info = 1
        write(*,"(/,' ### Wrong!',
     *  ' The Cartesian type number is out of range:',i3)")itype
        return
      end if

      l=PATDAT(1,itype)
      m=PATDAT(2,itype)
      n=PATDAT(3,itype)

      return
      end

c-----------------------------------------------------------------------
c---  B(*) = A(*)
c-----------------------------------------------------------------------
      Subroutine ACopy(N,A,B)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      Dimension A(*),B(*)

      Do I = 1,N
        B(I) = A(I)
      end do

      Return
      End

c-----------------------------------------------------------------------
c---  swap a and b
c-----------------------------------------------------------------------
      subroutine swap(a,b)
      implicit real*8 (a-h,o-z)

      scr=a
      a=b
      b=scr

      return
      end

c-----------------------------------------------------------------------
c---  C = C + A * B, where A and B are symmetric in L.T. and C is in Sq.
c     The following relationship is adopted:
c     M_sq(j,i) = M_lt(j+(i-1)*i/2) if j .le. i
c               = M_lt(i+(j-1)*j/2) if j .gt. i
c-----------------------------------------------------------------------
      subroutine LTxLT(N,A,B,C)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      parameter(half=0.5d0)
      Dimension A(*),B(*),C(N,N)

      do i = 1,N
        i0 = i*(i-1)/2
        X = A(i+i0)
        do j = 1,i
          C(j,i) = X * B(j+i0)
        end do
        do j = i + 1,N
          j0 = j*(j-1)/2
          C(j,i) = X * B(i+j0)
        end do
        do j = 1,i - 1
          j0 = j*(j-1)/2
          X = A(j+i0)
          do k = 1,j
            C(k,i) = C(k,i) + X * B(k+j0)
          end do
          do k = j+1,N
            k0 = k*(k-1)/2
            C(k,i) = C(k,i) + X * B(j+k0)
          end do
        end do
        do j = i + 1,N
          j0 = j*(j-1)/2
          X = A(i+j0)
          do k = 1,j
            C(k,i) = C(k,i) + X * B(k+j0)
          end do
          do k = j+1,N
            k0 = k*(k-1)/2
            C(k,i) = C(k,i) + X * B(j+k0)
          end do
        end do
      end do

      return
      end

c-----------------------------------------------------------------------
c     This subroutine is taken from BLAS.
c     Reference BLAS level1 routine (version 3.4.0) --
c     Reference BLAS is a software package provided by Univ. of Tennessee,
c     Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd.
c     November 2011
c-----------------------------------------------------------------------
      SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
c
c     .. Scalar Arguments ..
      DOUBLE PRECISION ALPHA,BETA
      INTEGER K,LDA,LDB,LDC,M,N
      CHARACTER TRANSA,TRANSB
c     ..
c     .. Array Arguments ..
      DOUBLE PRECISION A(LDA,*),B(LDB,*),C(LDC,*)
c     ..
c     .. Intrinsic Functions ..
      INTRINSIC MAX
c     ..
c     .. Local Scalars ..
      DOUBLE PRECISION TEMP
      INTEGER I,INFO,J,L,NCOLA,NROWA,NROWB
      LOGICAL NOTA,NOTB
c     ..
c     .. Parameters ..
      DOUBLE PRECISION ONE,ZERO
      PARAMETER (ONE=1.0D+0,ZERO=0.0D+0)
c     ..
c
c     Set  NOTA  and  NOTB  as  true if  A  and  B  respectively are not
c     transposed and set  NROWA, NCOLA and  NROWB  as the number of rows
c     and  columns of  A  and the  number of  rows  of  B  respectively.
c
      NOTA = TRANSA .eq. 'N'
      NOTB = TRANSB .eq. 'N'
      IF (NOTA) THEN
          NROWA = M
          NCOLA = K
      ELSE
          NROWA = K
          NCOLA = M
      END IF
      IF (NOTB) THEN
          NROWB = K
      ELSE
          NROWB = N
      END IF
c
c     Test the input parameters.
c
      INFO = 0
      IF ((.NOT.NOTA) .AND. (.NOT.(TRANSA .eq. 'C')) .AND.
     +    (.NOT.(TRANSA .eq. 'T'))) THEN
          INFO = 1
      ELSE IF ((.NOT.NOTB) .AND. (.NOT.(TRANSB .eq. 'C')) .AND.
     +         (.NOT.(TRANSB .eq. 'T'))) THEN
          INFO = 2
      ELSE IF (M.LT.0) THEN
          INFO = 3
      ELSE IF (N.LT.0) THEN
          INFO = 4
      ELSE IF (K.LT.0) THEN
          INFO = 5
      ELSE IF (LDA.LT.MAX(1,NROWA)) THEN
          INFO = 8
      ELSE IF (LDB.LT.MAX(1,NROWB)) THEN
          INFO = 10
      ELSE IF (LDC.LT.MAX(1,M)) THEN
          INFO = 13
      END IF
      IF (INFO.NE.0) THEN
          WRITE( *, FMT = 9999 ) INFO
          call estop
      END IF
c
c     Quick return if possible.
c
      IF ((M.EQ.0) .OR. (N.EQ.0) .OR.
     +    (((ALPHA.EQ.ZERO).OR. (K.EQ.0)).AND. (BETA.EQ.ONE))) RETURN
c
c     And if  alpha.eq.zero.
c
      IF (ALPHA.EQ.ZERO) THEN
          IF (BETA.EQ.ZERO) THEN
              DO 20 J = 1,N
                  DO 10 I = 1,M
                      C(I,J) = ZERO
   10             CONTINUE
   20         CONTINUE
          ELSE
              DO 40 J = 1,N
                  DO 30 I = 1,M
                      C(I,J) = BETA*C(I,J)
   30             CONTINUE
   40         CONTINUE
          END IF
          RETURN
      END IF
c
c     Start the operations.
c
      IF (NOTB) THEN
          IF (NOTA) THEN
c
c           Form  C := alpha*A*B + beta*C.
c
              DO 90 J = 1,N
                  IF (BETA.EQ.ZERO) THEN
                      DO 50 I = 1,M
                          C(I,J) = ZERO
   50                 CONTINUE
                  ELSE IF (BETA.NE.ONE) THEN
                      DO 60 I = 1,M
                          C(I,J) = BETA*C(I,J)
   60                 CONTINUE
                  END IF
                  DO 80 L = 1,K
                      IF (B(L,J).NE.ZERO) THEN
                          TEMP = ALPHA*B(L,J)
                          DO 70 I = 1,M
                              C(I,J) = C(I,J) + TEMP*A(I,L)
   70                     CONTINUE
                      END IF
   80             CONTINUE
   90         CONTINUE
          ELSE
c
c           Form  C := alpha*A**T*B + beta*C
c
              DO 120 J = 1,N
                  DO 110 I = 1,M
                      TEMP = ZERO
                      DO 100 L = 1,K
                          TEMP = TEMP + A(L,I)*B(L,J)
  100                 CONTINUE
                      IF (BETA.EQ.ZERO) THEN
                          C(I,J) = ALPHA*TEMP
                      ELSE
                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)
                      END IF
  110             CONTINUE
  120         CONTINUE
          END IF
      ELSE
          IF (NOTA) THEN
c
c           Form  C := alpha*A*B**T + beta*C
c
              DO 170 J = 1,N
                  IF (BETA.EQ.ZERO) THEN
                      DO 130 I = 1,M
                          C(I,J) = ZERO
  130                 CONTINUE
                  ELSE IF (BETA.NE.ONE) THEN
                      DO 140 I = 1,M
                          C(I,J) = BETA*C(I,J)
  140                 CONTINUE
                  END IF
                  DO 160 L = 1,K
                      IF (B(J,L).NE.ZERO) THEN
                          TEMP = ALPHA*B(J,L)
                          DO 150 I = 1,M
                              C(I,J) = C(I,J) + TEMP*A(I,L)
  150                     CONTINUE
                      END IF
  160             CONTINUE
  170         CONTINUE
          ELSE
c
c           Form  C := alpha*A**T*B**T + beta*C
c
              DO 200 J = 1,N
                  DO 190 I = 1,M
                      TEMP = ZERO
                      DO 180 L = 1,K
                          TEMP = TEMP + A(L,I)*B(J,L)
  180                 CONTINUE
                      IF (BETA.EQ.ZERO) THEN
                          C(I,J) = ALPHA*TEMP
                      ELSE
                          C(I,J) = ALPHA*TEMP + BETA*C(I,J)
                      END IF
  190             CONTINUE
  200         CONTINUE
          END IF
      END IF
c
      RETURN
c
c     End of DGEMM .
 9999 FORMAT( ' ** On entry to DGEMM parameter number ', I2, ' had ',
     $      'an illegal value' )
c
      END

c-----------------------------------------------------------------------
c---  spin of MO:
c     0: unknown
c     1: Alpha, or Alpha and Beta
c     2: Beta
c     NOTE: tmp must be in upper case and contains 'SPIN'
c-----------------------------------------------------------------------
      function MOspin(tmp)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      character*100 tmp

      if(index(tmp,'ALPHA').ne.0)then
        MOspin=1
      else if(index(tmp,'BETA').ne.0)then
        MOspin=2
      else
        MOspin=0
      end if

      return
      end

c-----------------------------------------------------------------------
